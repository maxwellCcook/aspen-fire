---
title: "Figures"
output: html_notebook
---

```{r include=F}
knitr::opts_knit$set(root.dir = '~/Library/CloudStorage/OneDrive-Personal/mcook/aspen-fire')
source('setup.R')
```

## STUDY AREA

```{r fig.height=5, fig.width=3.5}
ggplot() +
  geom_sf(data=srme) +
  geom_sf(data=wrnf, fill="darkgrey") +
  geom_sf(data=blocks, fill=NA, lwd=0.4) +
  coord_sf(crs="EPSG:32613") +
  theme_bw(11)
```

## Figure 1: Surface Reflectance / Spectral Response and Phenological Characteristics

```{r}

# Spectral Response
ts <- read_csv('../../data/tabular/mod/results/s2msi_l2a_aspen_TSy2019.csv', show_col_types = FALSE) %>% 
  select(-c(id,.geo,TCB,TCG,TCW))

# Join the observations to the spatial data and retrieve which block they relate to
ref_sp <- st_read("../../data/spatial/mod/training/points/gee/pi_points_srme_m500_.shp") %>%
  st_join(blocks) %>%
  rename(block_id = id)

ts <- ts %>% left_join(ref_sp%>%as_tibble()%>%select(uid,block_id), by="uid")

head(ts)

```

Tidy the time-series data.

1. Remove cloud-contaminated pixels,
2. Pivot the table to gather bands,
3. Generate mean/median/stdev of reflectance by image date,
4. Calculate weekly summaries

```{r fig.width=5, fig.height=3.5}

# Filter out cloud-contaminated pixels based on the Cloud Score + values
# Reference:  https://medium.com/google-earth/all-clear-with-cloud-score-bd6ee2e2235e

tsp <- ts %>%
  filter(
    cs >= 0.90, # >= 0.6 Cloud Score + contamination
  ) %>%
  # add the month as a column
  mutate(month = month(image_date, label=TRUE, abbr=TRUE)) %>%
  # Filter null values
  filter(complete.cases(.))

# Test using some visualizations

tsp %>%
  group_by(image_date) %>%
  summarize(band = median(NDRE)) %>%
  ggplot(aes(x=image_date,y=band)) +
  geom_point(size=0.8) +
  geom_smooth(method="loess") +
  labs(x="Image Date", y="NDRE") +
  theme_bw(11)

ggplot(data=tsp, aes(x=NDRE, y=month)) +
  geom_boxplot() +
  coord_flip() +
  labs(y="Image Date", x="NDRE") +
  theme_bw(11)

# rm(ts)

```

Now pivot the table longer:

```{r}

tsp_ <- tsp %>%
  select(c(starts_with("B"),image_date,
           SLAVI,NDRE,NDMI,ChlRE,IRECI,MCARI)) %>%
  group_by(image_date, block_id) %>%
  summarize_all(list(median)) %>%
  pivot_longer(
    cols = -c(image_date,block_id),
    names_to="band",
    values_to="reflectance"
  ) %>%
  # add a month and week label
  mutate(
    month = month(image_date, label=TRUE, abbr=TRUE),
    week = isoweek(image_date),
    biweek = cut.Date(image_date, breaks="2 week", labels=FALSE)
  )

# # Join back the phenology metrics
# blocks_df <- blocks %>% 
#   select(id,Greenup_1,MidGreenup_1,Maturity_1,Peak_1,MidGreendown_1,Dormancy_1) %>%
#   rename(
#     block_id = id,
#     greenup = Greenup_1,
#     midgreenup = MidGreenup_1,
#     maturity = Maturity_1,
#     peak = Peak_1,
#     midgreendown = MidGreendown_1,
#     dormancy = Dormancy_1
#   )
# 
# tsp_ <- tsp_ %>% 
#   left_join(blocks_df,by="block_id") %>%
#   as_tibble() %>%
#   select(-geom)
# 
# rm(blocks_df)

head(tsp_, n=19)

```

Breakpoint analysis to identify significant shift in spectral signature throughout the year based on NDRE:

```{r}

# Isolate one of the vegetation indices (Normalized Difference Red-edge Index)
df <- tsp_ %>% 
  filter(band == "NDRE") %>% 
  select(image_date,week,reflectance) %>%
  group_by(image_date,week) %>%
  summarize(reflectance = median(reflectance)) %>%
  ungroup()

# Create a weekly time-series object
df.ts <- ts(df$reflectance, frequency = 52)

# Implement the changepoint analysis based on NDRE
result <- changepoint::cpt.meanvar(df.ts, method="PELT")
bp.ind <- changepoint::cpts(result)

# Map breakpoints to dates
print("Breakpoint weeks:")
bp.dates <- df$week[bp.ind]
bp.dates

# print("Phenology weeks across spatial blocks:")
# print(paste0("Greenup = from week ",range(lubridate::week(tsp_$greenup))[1]," to ",range(lubridate::week(tsp_$greenup))[2]))
# print(paste0("MidGreenup = from week ",range(lubridate::week(tsp_$midgreenup))[1]," to ",range(lubridate::week(tsp_$midgreenup))[2]))
# print(paste0("Maturity = from week ",range(lubridate::week(tsp_$maturity))[1]," to ",range(lubridate::week(tsp_$maturity))[2]))
# print(paste0("Peak = from week ",range(lubridate::week(tsp_$peak))[1]," to ",range(lubridate::week(tsp_$peak))[2]))
# print(paste0("Mid Greendown = from week ",range(lubridate::week(tsp_$midgreendown))[1]," to ",range(lubridate::week(tsp_$midgreendown))[2]))
# print(paste0("Dormancy = from week ",range(lubridate::week(tsp_$dormancy))[1]," to ",range(lubridate::week(tsp_$dormancy))[2]))

# Plot the result
plot(result)

```

Perform the analysis by spatial block grid to get an idea of the variation in time-series breakpoints.

```{r}
results <- list()

for(block in unique(df$block_id)) {
    # Subset data for the block
    block_data <- df %>% filter(block_id == block)

    # Create time series (assuming weekly aggregation)
    block_ts <- ts(block_data$reflectance, frequency=52)

    # Perform breakpoint analysis
    block_result <- changepoint::cpt.meanvar(block_ts, method="PELT")

    # Store results with block identifier
    results[[block]] <- changepoint::cpts(block_result)
}

# Create an empty data frame to store breakpoint information
breakpoint_data <- data.frame(block_id = character(), breakpoint_week = integer())

# Loop through each block and add its breakpoints to the data frame
for(block in names(results)) {
    block_breakpoints <- results[[block]]
    block_data <- data.frame(block_id = rep(block, length(block_breakpoints)), 
                             breakpoint_week = block_breakpoints)
    breakpoint_data <- rbind(breakpoint_data, block_data)
}

# Convert the 'breakpoint_week' to actual dates
# This conversion depends on your specific date arrangement. Here's a basic example:
start_date <- as.Date("2019-01-02")  # Replace with your dataset's start date
breakpoint_data$breakpoint_date <- start_date + (breakpoint_data$breakpoint_week - 1) * 7

ggplot(breakpoint_data, aes(x = breakpoint_date, y = block_id, group = block_id)) +
    geom_line() +  # Optionally connect breakpoints in each block
    geom_point(size = 3) +  # Breakpoint markers
    theme_minimal() +
    labs(x = "Date", y = "Spatial Block") +
    theme(panel.grid.major.y = element_blank(),  # Removes horizontal grid lines
          panel.grid.minor.y = element_blank())
```

Plot of median daily observations:

```{r fig.height=5, fig.width=9}
# Reorder band factors
tsp_$band <- factor(tsp_$band, 
                   levels = c("B2","B3","B4","B5","B6",
                              "B7","B8","B8A","B11","B12",
                              "ChlRE","IRECI","NDMI","NDRE","SLAVI","MCARI"))

tsp_ %>%
  filter(str_detect(band,"B")) %>%
  ggplot(aes(x=image_date,y=reflectance ,color=factor(band))) +
  geom_line(linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  labs(x="Acquisition Date",y="Reflectance",color="S2 MSI Band") +
  theme_bw(14) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.text = element_text(size=10),
        legend.title = element_text(size=11))
```

# Figure 3: Spectral Response of Aspen Forest Presence Data

Gather the seasonal composite start and end dates:

```{r}
# Summer
(start_summer <- week(as.Date("2019-06-06")))
(end_summer <- week(as.Date("2019-08-25")))
# Autumn
(start_autumn <- week(as.Date("2019-09-27")))
(end_autumn <- week(as.Date("2019-11-01")))
```

Generate the weekly median reflectance.

```{r warning=F, message=F, fig.height=5, fig.width=9}

# List for band colors

band_colors <- c(
  "B2"  = "#1E90FF",  # Blue: Dodger Blue
  "B3"  = "#00FF7F",  # Green: Spring Green
  "B4"  = "#FF0000",  # Red: Pure Red
  "B5"  = "#FFA07A",  # Red Edge: Light Salmon
  "B6"  = "#FF8C00",  # NIR: Dark Orange
  "B7"  = "#D2691E",  # NIR: Chocolate
  "B8"  = "#FFD700",  # NIR: Gold
  "B8A" = "#B8860B",  # NIR: Dark Goldenrod
  "B11" = "#008B8B",  # SWIR: Dark Cyan (dark shade of teal)
  "B12" = "#800080"   # SWIR: Purple
)


# Group by week, calculate the mean, plot

f3a <- tsp_ %>%
  filter(str_detect(band,"B")) %>%
  group_by(band,week) %>%
  summarize(refl = mean(reflectance)) %>%
  ggplot(aes(x=week,y=refl,color=factor(band))) +
  geom_line(linewidth=0.6) +
  scale_color_manual(values = band_colors) +
  labs(x="Acquisition Week",y="Reflectance",color=NULL) +
  theme_bw(11) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8),
        legend.position = c(0.2,0.85),
        legend.direction = "horizontal",
        legend.background = element_rect(fill="white", color="black"),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial")) +
  annotate('rect', xmin=start_summer, xmax=end_summer, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  annotate('rect', xmin=start_autumn, xmax=end_autumn, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  geom_vline(xintercept=start_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=start_autumn, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_autumn, linetype="dotted", lwd=0.8)

f3a
```

Figure 1B: Time-series charts of the spectral indices:

```{r message=F, warning=F}

# All bands

tsp_ %>%
  group_by(band,week) %>%
  summarize(refl = mean(reflectance)) %>%
  ggplot(aes(x=week, y=refl, group=1)) +
  geom_line() +
  annotate('rect', xmin=start_summer, xmax=end_summer, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  annotate('rect', xmin=start_autumn, xmax=end_autumn, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  geom_vline(xintercept=start_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=start_autumn, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_autumn, linetype="dotted", lwd=0.8) +
  facet_wrap(. ~ band, scales = "free") +
  theme_minimal() +
  theme(axis.title.y = element_text(size=8,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=8,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=7),
        strip.text.x = element_text(size = 8))

# Spectral indices

f3b <- tsp_ %>%
  filter(!str_detect(band,"B")) %>%
  group_by(band,week) %>%
  summarize(refl = mean(reflectance)) %>%
  ggplot(aes(x=week, y=refl, group=1)) +
  geom_line(linewidth=0.6) +
  labs(x="Acquisition Week",y="Reflectance") +
  annotate('rect', xmin=start_summer, xmax=end_summer, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  annotate('rect', xmin=start_autumn, xmax=end_autumn, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  geom_vline(xintercept=start_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=start_autumn, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_autumn, linetype="dotted", lwd=0.8) +
  facet_wrap(. ~ band, scales = "free") +
  theme_light(11) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3b

```

Figure 3C: Boxplot of seasonal composites:

```{r}

# Reorder band factors
tsp_$band <- factor(tsp_$band, 
                   levels = c("B2","B3","B4","B5","B6",
                              "B7","B8","B8A","B11","B12",
                              "ChlRE","IRECI","NDMI","NDRE","SLAVI","MCARI"))

cols <- c(
  "Summer" = "#87CEEB", 
  "Autumn" = "#DAA520"
)

seasonal <- tsp_ %>%
  mutate(season = if_else(week>=22&week<=37,"Summer","na"),
         season = if_else(week>=37&week<=48,"Autumn",season)) %>%
  filter(season!="na")

seasonal$season <- factor(seasonal$season, levels = c("Summer","Autumn"))
  
f3c <- seasonal %>%
  filter(str_detect(band,"B")) %>%
  ggplot(aes(x=band,y=reflectance,fill=season)) +
  geom_boxplot(outlier.size = 0.5, outlier.color = "grey30") +
  scale_fill_manual(values = cols) +
  theme_bw(16) +
  labs(x="Sentinel-2 MSI Band",y="Reflectance") +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.position = "none",
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3c

```

Figure 1D: Seasonal differences in the spectral indices

```{r}

f3d <- seasonal %>%
  filter(!str_detect(band,"B")) %>%
  ggplot(aes(y=reflectance)) +
  geom_boxplot(aes(fill=season)) +
  scale_fill_manual(values = cols) +
  facet_wrap(. ~ band, scales = "free") +
  theme_bw(14) +
  labs(fill="Season",y="Value") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        legend.position = c(0.85,0.2),
        legend.title = element_text(size=16),
        legend.text = element_text(size=15),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3d

```

Combine the plots:

```{r fig.width=14, fig.height=8, message=F}

# Arrange in a multi-panel plot

f3 <- ggarrange(f3a,f3b,f3c,f3d, nrow=2,ncol=2,widths=c(1, 0.75), labels = c("A", "B", "C", "D"))
f3

# Save it out

ggsave(f3, file = "../../figures/Figure3_SpectralResponse.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Version 2:

```{r fig.width=14, fig.height=8}

f3_ <- ggarrange(f3a,ggarrange(f3c,f3d,nrow=1,ncol=2),
                  ncol=1,widths=c(1, 0.75),
                  labels = c("A", "B", "C"))
f3_

ggsave(f3_, file = "../../figures/Figure3_SpectralResponse_v2.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Clean up the time-series / spectral response data:

```{r}
rm(f3,f3_,f3a,f3b,f3c,f3d,seasonal,tsp,band_colors,cols,end_autumn,end_summer,start_autumn,start_summer)
gc()
```

## Figure 4: Model accuracy and feature importance plot

Best Performing Model:

Plot the AUC-PR and AUC-ROC.

```{r}
glimpse(accmeas)
```

Calculate the model averages using the optimum cutoff value:

```{r}
# Without taking the average

print("~~~~~Total (not averageing) based on maximum F1~~~~~")

paste0("Cutoff: ",(cutoffOptF1 = accmeas[which.max(accmeas$f1),]$cutoff))
paste0("Precision: ",(precisionOptF1 = accmeas[which.max(accmeas$f1),]$precision))
paste0("Recall: ",(recallOptF1 = accmeas[which.max(accmeas$f1),]$recall))
paste0("FPR: ",(fprOpt = accmeas[which.max(accmeas$f1),]$fpr))
paste0("TPR: ",(tprOpt = accmeas[which.max(accmeas$f1),]$tpr))
paste0("Max F-score: ",(max_f1 = max(accmeas$f1, na.rm=TRUE)))

# With the aggregation/averaging across models and threshold values

# Calculate the averages for each cutoff value across model runs

accmeas.mn <- accmeas %>%
  mutate(cutoff = as.character(cutoff)) %>%
  group_by(cutoff) %>%
  summarise(
    prMn = mean(prSize,na.rm=T), # size of presence data (mean)
    prSd = sd(prSize,na.rm=T), # size of presence data (sd)
    bgMn = mean(bgSize,na.rm=T), # size of background data (mean)
    bgSd = sd(bgSize,na.rm=T), # size of background data (sd)
    fprMn = mean(fpr,na.rm=T), # False Positive Rate (mean)
    fprSd = sd(fpr,na.rm=T),
    tprMn = mean(tpr,na.rm=T), # True Positive Rate (mean)
    tprSd = sd(tpr,na.rm=T),
    precision = mean(precision,na.rm=T), # precision (mean)
    precisionSd = sd(precision,na.rm=T), 
    recall = mean(recall,na.rm=T), # recall (mean)
    recallSd = sd(recall,na.rm=T),
    f1 = mean(f1,na.rm=T), # F1 score (mean)
    f1Sd = sd(f1,na.rm=T),
    gmean = mean(gmean,na.rm=T), # Geometric Mean (mean)
    gmeanSd = sd(gmean,na.rm=T),
    mcc = mean(mcc,na.rm=T), # Matthew's Correlation Coefficient (mean)
    mccSd = sd(mcc,na.rm=T),
    accuracy = mean(accuracy,na.rm=T), # Overall accuracy (mean)
    accuracySd = sd(accuracy,na.rm=T)
  ) %>%
  ungroup() %>%
  mutate(cutoff = round(as.double(cutoff),3))

# Calculate optimum threshold based on F1 statistic

print("~~~~~Model averages and maximum F-score~~~~~")

(cutoffOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$cutoff)
(precisionOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$precision)
(recallOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$recall)
(fprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$fprMn)
(tprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$tprMn)
(max_f1Mn <- max(accmeas.mn$f1, na.rm = TRUE))

```

```{r}
# F1 based
print("F1-based accuracy metrics")
paste0("F1 Score: ",(f1Opt = accmeas.mn[which.max(accmeas.mn$f1),]$f1))
paste0("Overall Accuracy: ",(oaOpt = accmeas.mn[which.max(accmeas.mn$f1),]$accuracy))
paste0("Precision: ",(precOpt = accmeas.mn[which.max(accmeas.mn$f1),]$precision))
paste0("Recall: ",(recOpt = accmeas.mn[which.max(accmeas.mn$f1),]$recall))
paste0("Cutoff: ",(threshOpt = accmeas.mn[which.max(accmeas.mn$f1),]$cutoff))

# Mathews Correlation Coefficient
print("---------------------------")
print("MCC-based accuracy metrics")
paste0("MCC: ",(mccOpt = accmeas.mn[which.max(accmeas.mn$mcc),]$mcc))
paste0("Overall Accuracy: ",(oaOptmcc = accmeas.mn[which.max(accmeas.mn$mcc),]$accuracy))
paste0("Precision: ",(precOptmcc = accmeas.mn[which.max(accmeas.mn$mcc),]$precision))
paste0("Recall: ",(recOptmcc = accmeas.mn[which.max(accmeas.mn$mcc),]$recall))
paste0("Cutoff: ",(threshOptmcc = accmeas.mn[which.max(accmeas.mn$mcc),]$cutoff))
```

Plot the model accuracy results for the optimum threshold.

```{r}

# Get the best F1 score for each model run
accmeas.best <- accmeas %>% 
  group_by(factor(model)) %>% 
  top_n(1,f1) %>%
  ungroup() %>%
  mutate(model_iter = row_number())

print(paste0("Cutoff: Mean = ",round(mean(accmeas.best$cutoff),3),"; Standard Deviation: ",round(sd(accmeas.best$cutoff),3)))
print(paste0("F1 Score: Mean = ",round(mean(accmeas.best$f1),3),"; Standard Deviation: ",round(sd(accmeas.best$f1),3)))

```

Check on the optimum threshold by spatial block:

```{r}

```

Figure 4A: Model Accuracy (F1 and OA)

```{r message=F, warning=F}

cols <- c("F1 Score"="#1f78b4","Overall Accuracy"="gray75")

f4a <- ggplot(data=accmeas.best) +
  geom_hline(yintercept=0.972760973096824,linetype="dashed",color="gray85") +
  geom_hline(yintercept=0.910339477355629,linetype="dashed",color="#1f78b4") +
  geom_line(aes(x=factor(model_iter),y=accuracy,group=1),color="gray65") +
  geom_line(aes(x=factor(model_iter),y=f1,group=1),color="#1f78b4") +
  geom_point(aes(x=factor(model_iter),y=f1,size=f1), color="#1f78b4") +
  geom_point(aes(x=factor(model_iter),y=accuracy,size=accuracy), color="gray65") +
  scale_size(range = c(3,6)) +
  coord_cartesian(ylim = c(0.85, 1)) +
  labs(x="Model Iteration", y="Score", tag="A") +
  annotate("text", x = 3, y = 0.99, label = paste("Average Overall Accuracy: ", round(oaOpt, 2))) +
  annotate("text", x = 2.6, y = 0.88, label = paste("Average F1 Score: ", round(f1Opt, 2))) +
  theme_bw() +
  guides(size="none") +
  theme(
        plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        text = element_text(family = "Arial"))
f4a

ggsave(f4a, file = "../../figures/Figure4A_Best_Model_Acc_F1.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Figure 4B: Sensitivity Analysis

```{r}

# Labels for each model subset

labels_ = c(
  "winter_sar" = "M1", 
  "summer_sar" = "M2",
  "summer_winter_sar_text" = "M3",
  "summer_winter_sar" = "M4",
  "autumn_spectral" = "M5",
  "summer_spectral" = "M6",
  "summer_spectral_ind" = "M7",
  "spectral_sar_ind" = "M8",
  "summer_autumn_spectral" = "M9",
  "spectral_sar" = "M10",
  "final" = "Final Model"
)

# Add in the final model to the sensitivity analysis

add <- accmeas.best %>%
  ungroup() %>%
  select(model,f1) %>%
  mutate(subset = "final") %>%
  rename(f1Max = f1)
glimpse(add)
accmeas.s <- accmeas.s %>%
  bind_rows(add)
rm(add)

print(unique(accmeas.s$subset))

# Generate the box plots of F1 score

f4b <- ggplot(data=accmeas.s, aes(x=reorder(subset,f1Max),y=f1Max)) +
  geom_boxplot() +
  scale_x_discrete(labels=labels_) +
  labs(x="Input Features",y="Maximum F1 Score", tag="B") +
  theme_bw(11) +
  theme(
        plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        axis.text.x = element_text(angle = 45, hjust=1),
        text = element_text(family = "Arial"))
f4b

# Save out

ggsave(f4b, file = "../../figures/Figure4B_Model_Sensitivity.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```

Combine the two figures for Figure 4AB:

```{r fig.width=7.5, fig.height=6}

f4 <- ggarrange(f4a,f4b,nrow=2)
f4

ggsave(f4, file = "../../figures/Figure4AB_Model_Accuracy_Sensitivity.png",
       width=7.5, height=7.5, dpi = 300, bg="white") # adjust dpi accordingly

```

## Figure 6: Feature importance from the best model

```{r}
glimpse(ftr_imp)
```

```{r message=F, warning=F}

# # Tidy the data frame
# df.imp <- ftr_imp %>% 
#   select(-c(.geo,`system:index`)) %>%
#   rename(model = seed) %>%
#   mutate(model = as.factor(model)) %>%
#   # Summarize across to grab the relative importance
#   rowwise() %>%
#   mutate(total = sum(c_across(B11_autumn:VV_winter_ent))) %>%
#   ungroup() %>%
#   mutate(across(B11_autumn:VV_winter_ent, ~ . * 100 / total)) %>%
#   select(-total)
# glimpse(df.imp)

# Tidy the data frame
df.imp <- ftr_imp %>% 
  select(-c(.geo,`system:index`)) %>%
  rename(model = seed) %>%
  mutate(model = as.factor(model)) %>%
  # Summarize across to grab the relative importance
  group_by(model) %>%
  mutate(total = sum(across(B11_autumn:VV_winter_ent))) %>%
  mutate(across(B11_autumn:VV_winter_ent, ~ . / total)) %>%
  ungroup() %>%
  select(-total)

```

```{r}

# Pivot longer
df.imp.p <- df.imp %>%
  pivot_longer(cols = -model) %>%
  rename(importance = value,
         band = name) %>%
  mutate(season = if_else(str_detect(band,"_autumn"), "Autumn Spectral", "Summer Spectral"),
         season = if_else(str_detect(band,"VV_winter"), "Winter SAR", season),
         season = if_else(str_detect(band,"VH_winter"), "Winter SAR", season),
         season = if_else(str_detect(band,"VV_summer"), "Summer SAR", season),
         season = if_else(str_detect(band,"VH_summer"), "Summer SAR", season))
glimpse(df.imp.p)

```

```{r message=F}

# Grab the top 20 over all model runs

top <- df.imp.p %>%
  group_by(band) %>%
  summarize(median = median(importance)) %>%
  ungroup()

top <- head(arrange(top,desc(median)), n = 20)

# Color palette

cols <- c(
  "Summer Spectral" = "#87CEEB", 
  "Autumn Spectral" = "#DAA520",
  "Winter SAR" = "gray29",
  "Summer SAR" = "gray89"
)

# Boxplot

# %>% filter(band %in% top$band)
f6 <- ggplot(data=df.imp.p %>% filter(band %in% top$band), 
              aes(x=reorder(band,importance), fill=season)) +
  geom_boxplot(aes(y=importance), position = position_dodge(0.5)) +
  scale_fill_manual(values = cols, 
                    labels = c("Autumn Spectral","Summer SAR","Summer Spectral","Winter SAR")) +
  coord_flip() +
  theme_bw(11) +
  theme(axis.text.x = element_text(size=11),
        axis.text.y = element_text(angle = 0, vjust=0, size=11),
        axis.title = element_text(size=11,face="italic"),
        legend.position = "bottom",
        legend.justification = c(1.2,0.5), # Left-aligns the legends
        legend.text = element_text(size=11),
        text = element_text(family = "Arial"),
        plot.margin=unit(c(0.5,0.5,0.5,0.5),"cm")) +
  labs(x="Feature", y="Importance", fill="Season: ")
f6

ggsave(f6, file = "../../figures/Figure6_FeatureImportance.png",
       dpi=300, bg="white") # adjust dpi accordingly

```

Clean up!

```{r}
rm(list = ls.str(mode = 'numeric'))
rm(accmeas,accmeas.best,accmeas.mn,accmeas.s,df.imp,
   df.imp.p,f4,f4a,f4b,f6,ftr_imp,top,labels_,cols)
gc()
```

## Figures 7, 8 - Case Study: Landscape Patch Dynamics

# Figure 7: Spatial Agreement

```{r}

cols <- c("#4DAF4A", "#984EA3", "#FF7F00")
flabs <- c(prec = "Precision", rec = "Recall", f1 = "F1-score")

# Reshape the agreement table for plotting facet wrap

# Southern Rockies (by block)
ref.srme_m <- reshape2::melt(
  ref.srme, id.vars = c("blocksize", "source", "region", "grid_id"), 
  measure.vars = c("prec", "rec", "f1"), variable.name = "statistic"
) %>%
  na.omit()

# WRNF as a whole
ref.wrnf_m <- reshape2::melt(
  ref.wrnf, id.vars = c("blocksize", "source", "region"), 
  measure.vars = c("prec", "rec", "f1"), variable.name = "statistic"
) %>%
  na.omit()

# Facet wrap plot of the statistics by block group

f7 <- ggplot(data=ref.srme_m, aes(x=factor(blocksize), y=value, fill=factor(source))) +
  geom_boxplot(position = position_dodge()) + 
  scale_fill_manual(values=cols, labels=c("LANDFIRE EVT","USFS TreeMap","USFS ITSP"), name="Source: ") +
  facet_wrap(~statistic, labeller = labeller(statistic = flabs)) +
  theme_light(11) +
  theme(legend.position = "top",
        legend.box = "vertical",
        legend.justification = c(0.5,0.5), # Left-aligns the legends
        legend.spacing.y = unit(-10, "pt"), # Adjusts the gap between the legends
        legend.text = ggtext::element_markdown(halign = 0), # This aligns each individual legend's text to the left
        axis.title = element_text(size=12,face="italic"),
        text = element_text(family = "Arial")) +
  labs(x="Blocksize",y="Value")

# Add the WRNF statistics
f7 <- f7 +
  # Plot the WRNF points on top as a different shape
  geom_point(data=ref.wrnf_m, aes(x=factor(blocksize), y=value, shape=region), 
             position = position_dodge(width = 0.75), size = 3, color="black") +
  scale_shape_manual(name="Subregion", values=c("WRNF" = 8)) +
  guides(
    fill=guide_legend(override.aes=list(shape=NA)), # No shape in the fill legend
    shape=guide_legend(title="Subregion", override.aes=list(color="black")) # Shape legend for Subregion
  )

f7

# Add a spatial map of statistics by blocks
blocks_ <- blocks %>%
  left_join(ref.srme, by="grid_id") %>%
  pivot_longer(cols = c(prec, rec, f1), names_to = "statistic", values_to = "value")

ggplot(data = blocks_) +
  geom_sf(aes(fill = value)) +
  facet_grid(source ~ statistic) +
  scale_fill_viridis_c(option = "C") + # Use a continuous color scale
  theme_void() +
  theme(
    strip.text.x = element_text(size = 10),
    legend.position = "bottom"
  ) +
  guides(fill = guide_colourbar(direction = "horizontal", barwidth = 10, barheight = 0.60,
                                ticks=F, title.position = "left"),
         label.theme = element_text(angle = 0, size = 9)) +
  labs(fill="")

```


```{r}

brewer.pal(n=5,"Set1")

cols <- c("#4DAF4A", "#984EA3", "#FF7F00")

glimpse(ref.global)

# # Get an average f1 score table
# f1mn <- ref.global %>%
#   group_by

# Add a statistics column for legend (could do this for F1 too ...)
ref.global.m <- reshape2::melt(
  ref.global, id.vars = c("blocksize", "source", "region"), 
  measure.vars = c("prec", "rec"), variable.name = "statistic"
)

glimpse(ref.global.m)

f7a <- ggplot(data=ref.global.m) +
  geom_line(aes(x=blocksize,y=value,color=factor(source), linetype=statistic), linewidth=0.6) +
  geom_point(data=ref.global, aes(x=blocksize, y=f1, color=source)) +
  scale_x_continuous(breaks=c(1,3,5,7,9)) +
  scale_linetype_manual(values = c("prec" = "dotted", "rec" = "solid"), name="Statistic: ",
                        labels=c("Precision","Recall")) +
  facet_wrap(~region, scales = "fixed") +
  scale_color_manual(values=cols, labels=c("LANDFIRE EVT","USFS TreeMap","USFS ITSP"), name="Source: ") +
  theme_light(14) +
  ylim(0,1) +
  theme(legend.position = "top",
        legend.box = "vertical",
        legend.justification = c(0.5,0.5), # Left-aligns the legends
        legend.spacing.y = unit(-10, "pt"), # Adjusts the gap between the legends
        legend.text = ggtext::element_markdown(halign = 0), # This aligns each individual legend's text to the left
        axis.title = element_text(size=12,face="italic"),
        text = element_text(family = "Arial")) +
  labs(x="Blocksize (pixels)",y="Value")
  
f7a

ggsave(f7a, file = "../../figures/Figure7_Global_PrecRec_Agreement.png", dpi=300)

```

Focal accuracy:

```{r message=F}

# ref.focal$refbudens <- log(1 + ref.focal$tp + ref.focal$fn)
# 
# ggplot(ref.focal %>% filter(region=="SRME"), aes(x = prec, y = rec, color = refbudens)) +
#    geom_point(size = 2, alpha = 0.9) +
#    scale_color_viridis_c() +
#    facet_grid(rows = vars(geog_scale), cols = vars(blocksize), scales = "fixed") +
#    theme_light() +
#    labs(
#       title = 'Spatially explicit accuracy: Precision (x) vs. Recall (y)',
#       subtitle = 'for multiple analytical units and spatial support levels',
#       color = 'refbudens',
#       x = 'Precision',
#       y = 'Recall'
#    ) +
#    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
#    theme(legend.position = "bottom")

```

Join the two plots:

```{r}
# f7 <- ggarrange(global_precrec,focal.prec,focal.rec,nrow=1,labels=c("A","B","C"))
# f7
# ggsave(f7, file="../../figures/Figure7_Global_Focal_Agreement.png", dpi=300)
```

Clean up! 

```{r}
rm(ref.global,ref.global.m,f7a,f7b,f7,ref.focal)
gc()
```

# Figure 8: Landscape Patch Dynamics

```{r}
unique(factor(patch_metrics$source))
summary(patch_metrics)
```

Calculate some grouped statistics (to compare with the class metrics results)

```{r message=F, warning=F, fig.height=8, fig.width=8}

# Also create a grouped summary
(patch.summary <- patch_metrics %>%
  group_by(source,region) %>%
  summarize(area_md = median(area), # convert to hectares
            area_mn = mean(area),
            area_sum = sum(area),
            perim_md = median(perimeter),
            perim_mn = mean(perimeter),
            par_md = median(perimeter_area_ratio),
            par_mn = mean(perimeter_area_ratio),
            si_md = median(shape_index),
            si_mn = mean(shape_index)) %>%
  ungroup())

(patch.long <- patch.summary %>%
  pivot_longer(cols = c(contains("_")),
               names_to = "metric",
               values_to = "value"))

patch.long$source <- factor(patch.long$source,levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))

(ggplot(data = patch.long, aes(x=source, y=value, fill=region)) +
    geom_bar(stat="identity", position="dodge", width=0.7) +
    facet_wrap(~metric, scales="free") + 
    theme_minimal(14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
    text = element_text(family = "Arial")))

(f8s <- ggplot(data = patch.long, aes(x=source, y=value, fill=region)) +
    geom_bar(stat="identity", position="dodge", width=0.7) + 
    theme_minimal(14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
    text = element_text(family = "Arial")))

```

Grab some summary statistics on the patch dynamics:

```{r}

a <- patch.long %>% filter(region=="SRME",metric=="area_mn",source=="Aspen10m")
b <- patch.long %>% filter(region=="SRME",metric=="area_mn",source=="LFEVT")

print("Difference in mean patch size for the SRME: ")
((b$value-a$value)/b$value)*100

a <- patch.long %>% filter(region=="WRNF",metric=="area_mn",source=="Aspen10m")
b <- patch.long %>% filter(region=="WRNF",metric=="area_mn",source=="LFEVT")

print("Difference in mean patch size for the WRNF: ")
((b$value-a$value)/b$value)*100

print("~~~~~~~~~~~~~~~~")

print("Difference in mean patch size for the SRME: ")
((b$value-a$value)/b$value)*100

(c <- patch.long %>% filter(metric=="area_md",source=="Aspen10m"))
(d <- patch.long %>% filter(metric=="area_md",source=="LFEVT"))

print("Mean and median patch sizes: ")
paste0("Aspen10m mean: ",a$value)
paste0("LFEVT mean: ",b$value)
paste0("Aspen10m median: ",c$value)
paste0("LFEVT mean: ",d$value)



print("Difference in median area: ")
((d$value-c$value)/d$value)*100

print("Mean Perimeter area ratio: ")
(a <- patch.long %>% filter(metric=="par_mn",source=="Aspen10m"))
(b <- patch.long %>% filter(metric=="par_mn",source=="LFEVT"))

print("Difference in PAR: ")
((b$value-a$value)/b$value)*100

rm(a,b,c,d)
```

Boxplot as facet wrap for patch metrics:

```{r fig.height=5, fig.width=10}

brewer.pal(n=5,"Set1")

cols <- c("#005a32","#a1d99b")

(df <- patch_metrics %>%
  # mutate(area_ha = area*100) %>%
  select(-c(X,index,shape_index)) %>%
  pivot_longer(contains(c("area","perimeter_area_ratio"))) %>%
  arrange(source, desc(value)) %>%
  mutate(name = as.character(name),
         name = recode(name,
                       "area" = "Patch Size (ha)",
                       "perimeter_area_ratio" = "Perimeter/Area Ratio")))

df$source <- factor(df$source,
                    levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))
 
(f8a <- ggplot(data=df, aes(y = value, x = factor(source), fill = factor(region))) +
  geom_boxplot(outlier.size = 0.2) +
  scale_y_continuous(trans="log10",labels=label_number_si(accuracy = 1)) +
  scale_fill_manual(values=cols) +
  facet_wrap(~name, scales = "free_y", nrow=1) +
  labs(x="\nData Source",y="Value",title="Patch Metrics", fill="Region: ") +
  theme_light(12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=11),
        axis.text.y = element_text(angle = 0, vjust=0.1, size=11),
        axis.title.y = element_text(size=12, face="italic", vjust=1),
        axis.title.x = element_text(size=12, face="italic", vjust=-1),
        plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm"),
        legend.position="top",
        legend.spacing.x = unit(0.5,"cm"),
        text = element_text(family = "Arial")))

ggsave(f8a, file = "../../figures/Figure8A_patch_metrics.png", dpi = 300) # adjust dpi accordingly

```

Plot class metrics as facet wrap:

```{r fig.height=5, fig.width=10, message=F}

# Calculate area in square meters
srme_area_km2 <- st_area(srme) / 1e6
wrnf_area_km2 <- st_area(wrnf) / 1e6

(df <- class_metrics %>%
  mutate(total_area = total_area*0.01,
         prop_area = if_else(region=="SRME", as.double((total_area/srme_area_km2*100)), 0.0),
         prop_area = if_else(region=="WRNF", as.double((total_area/wrnf_area_km2*100)), prop_area)) %>%
  select(-c(X)) %>%
  pivot_longer(cols = c(contains("_")),
               names_to = "metric",
               values_to = "value") %>%
  mutate(metric = as.character(metric),
         metric = recode(metric,
                         "n_patch" = "Number of Patches",
                         "patch_den" = "Patch Density",
                         "total_area" = "Total area (km2)",
                         "prop_area" = "Proportion of Area")))

df$source <- factor(df$source, levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))
head(df)

(f8b <- ggplot(data=df, aes(y=value, x=factor(source), fill=factor(region))) +
  geom_bar(stat="identity", position="dodge", width=0.7) +
  scale_y_continuous(labels=scales::label_number_si(accuracy = 1)) +
  scale_fill_manual(values=cols) +
  labs(x="", y="Value", title="Landscape Metrics", fill="Region: ") +
  theme(axis.title.x = NULL) +
  facet_wrap(~metric, scales = "free_y") +
  theme_light(12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=11),
        axis.text.y = element_text(angle = 0, vjust=0.1, size=11),
        axis.title.y = element_text(size=12, face="italic", vjust=0.5),
        axis.title.x = element_text(size=12, face="italic", vjust=-0.5),
        plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm"),
        legend.position = "top",
        legend.spacing.x = unit(0.5,"cm"),
        text = element_text(family = "Arial")))

ggsave(f8b, file = "../../figures/Figure8B_landscape_metrics.png", dpi = 300) # adjust dpi accordingly

```

```{r fig.width=10, fig.height=10}
(arr <- ggarrange(f8b,f8a,nrow=2,ncol=1,labels=c("A","B"), common.legend = T))
ggsave(arr, file="../../figures/Figure8_Landscape_Patch_Metrics.png", dpi=300)
```

The 10-m aspen classification identified Xx more patch than reference images:

```{r}

print("% Difference in number of patches across the Southern Rockies: ")
a <- df %>% filter(region=="SRME",metric=="Number of Patches",source=="Aspen10m")
b <- df %>% filter(region=="SRME",metric=="Number of Patches",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("% Difference in number of patches across the White River NF: ")
a <- df %>% filter(region=="WRNF",metric=="Number of Patches",source=="Aspen10m")
b <- df %>% filter(region=="WRNF",metric=="Number of Patches",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("~~~~~~~~~~~~~")

print("~~~~~~~~~~~~~")

print("% Difference in patch density: ")
a <- df %>% filter(metric=="Patch Density",source=="Aspen10m")
b <- df %>% filter(metric=="Patch Density",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("% Difference in total area:")
a <- df %>% filter(metric=="Total area (km2)",source=="Aspen10m")
aa <- df %>% filter(metric=="Total area (km2)",source=="Aspen30m")
b <- df %>% filter(metric=="Total area (km2)",source=="LFEVT")
((b$value-a$value)/b$value)*100
((b$value-aa$value)/b$value)*100

rm(a,aa,b)

```


# Supplemental

Figure S1: Phenology across the SRME study region

```{r}

# Spatial map(s) of key phenological metrics

breaks_dates <- as.Date(c("2020-01-01", "2021-01-01", "2022-01-01"))
breaks_numeric <- as.numeric(breaks_dates)  # Convert to numeric (days since 1970-01-01, by default)
labels_dates <- format(breaks_dates, "%Y-%m-%d")

p1 <- ggplot(data=blocks) +
  geom_sf(aes(fill=Maturity_1)) +
  scale_fill_continuous(low = "lightgreen", high = "darkgreen",
                        labels = function(x) format(as.Date(as.numeric(x), origin="1970-01-01"), "%B %d")) +
  geom_sf(data=srme,fill=NA,color="black",size=2.5) +
  labs(fill="Maturity") +
  guides(fill = guide_colourbar(barwidth = 0.5, barheight = 5.5, ticks=F,
                                 label.position = "right", title.position = "top",
                                 label.theme = element_text(angle = 0, size = 8))) +
  theme_void()

p2 <- ggplot(data=blocks) +
  geom_sf(aes(fill=Dormancy_1)) +
  scale_fill_continuous(low = "#ffffd4", high = "#993404",
                        labels = function(x) format(as.Date(as.numeric(x), origin="1970-01-01"), "%B %d")) +
  geom_sf(data=srme,fill=NA,color="black",size=2.5) +
  labs(fill="Dormancy") +
  guides(fill = guide_colourbar(barwidth = 0.5, barheight = 5.5, ticks=F,
                                 label.position = "right", title.position = "top",
                                 label.theme = element_text(angle = 0, size = 8))) +
  theme_void()

ggarrange(p1,p2)

# # Add a statistics column for legend (could do this for F1 too ...)
# blocks.m <- reshape2::melt(
#   blocks, id.vars = c("id","elevation_mn"), 
#   measure.vars = c("Greenup_1","MidGreenup_1","Maturity_1","Peak_1",
#                    "MidGreendown_1","Senescence_1","Dormancy_1"), variable.name = "metric"
# )

# Add a statistics column for legend (could do this for F1 too ...)
blocks.m <- reshape2::melt(
  blocks, id.vars = c("id","elevation_mn"), 
  measure.vars = c("Greenup_1","Maturity_1","Peak_1","Dormancy_1"), variable.name = "metric"
) %>%
  mutate(metric = as.character(metric),
         metric = as.factor(recode(metric,
                         "Greenup_1" = "Greenup",
                         "Maturity_1" = "Maturity",
                         "Peak_1" = "Peak Greenness",
                         "Dormancy_1" = "Dormancy")))
  
blocks.m$metric <- factor(blocks.m$metric, levels=c('Greenup', 'Maturity', 'Peak Greenness', 'Dormancy'))

head(blocks.m)

# Dot plot of phenology metric by elevation for all blocks

(p5 <- ggplot(data=blocks.m, aes(x=value,y=elevation_mn)) +
  geom_smooth(method="lm",colour="gray40", fill="gray70", size=0.8) +
  geom_point(size=1.2) +
  facet_wrap(~metric, scales="free_x") +
  theme_light(12) +
    labs(x="Date",y="Elevation"))

(p6 <- ggplot(data=blocks.m, aes(x=value,y=elevation_mn,color=metric)) +
  geom_point(size=1.2) +
  theme_light(12))

```


ROC, F1, MCC:

```{r}

accmeas <- read_csv('../../data/tabular/mod/results/accmeas_prop.csv')

# Calculate the averages for each cutoff value across model runs

accmeas.mn <- accmeas %>%
  mutate(cutoff = as.character(cutoff)) %>%
  group_by(cutoff) %>%
  summarise(
    prMn = mean(prSize,na.rm=T), # size of presence data (mean)
    prSd = sd(prSize,na.rm=T), # size of presence data (sd)
    bgMn = mean(bgSize,na.rm=T), # size of background data (mean)
    bgSd = sd(bgSize,na.rm=T), # size of background data (sd)
    fprMn = mean(fpr,na.rm=T), # False Positive Rate (mean)
    fprSd = sd(fpr,na.rm=T),
    tprMn = mean(tpr,na.rm=T), # True Positive Rate (mean)
    tprSd = sd(tpr,na.rm=T),
    precision = mean(precision,na.rm=T), # precision (mean)
    precisionSd = sd(precision,na.rm=T), 
    recall = mean(recall,na.rm=T), # recall (mean)
    recallSd = sd(recall,na.rm=T),
    f1 = mean(f1,na.rm=T), # F1 score (mean)
    f1Sd = sd(f1,na.rm=T),
    gmean = mean(gmean,na.rm=T), # Geometric Mean (mean)
    gmeanSd = sd(gmean,na.rm=T),
    mcc = mean(mcc,na.rm=T), # Matthew's Correlation Coefficient (mean)
    mccSd = sd(mcc,na.rm=T),
    accuracy = mean(accuracy,na.rm=T), # Overall accuracy (mean)
    accuracySd = sd(accuracy,na.rm=T)
  ) %>%
  ungroup() %>%
  mutate(cutoff = round(as.double(cutoff),3))

# Calculate optimum threshold based on F1 statistic

cutoffOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$cutoff
precisionOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$precision
recallOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$recall
fprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$fprMn
tprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$tprMn
max_f1 <- max(accmeas.mn$f1, na.rm = TRUE)

```


```{r warning=F, message=F}

# ROC Curve and label the AUC value (approximation)

# Get the AUC approx

# Ensure data is sorted by FPR
accmeas_mn_sorted <- accmeas.mn[order(accmeas.mn$fprMn), ]
# Compute AUC using trapz function in 'pracma'
auc_avg_approx <- trapz(accmeas_mn_sorted$fprMn, accmeas_mn_sorted$tprMn)

fs2a <- ggplot(data=accmeas) +
  geom_line(aes(x=fpr,y=tpr,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  geom_line(data=accmeas.mn, aes(x = fprMn, y = tprMn), color = "black", size = 0.8) +  # ROC curve average
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='False Positive Rate', y='True Positive Rate', tag="A") +
  geom_point(aes(x = fprOptMn, y = tprOptMn),
             color = "red", size = 3, shape = 19) +  # optimal threshold point
  geom_text(aes(x=fprOptMn, y=tprOptMn),
            label = paste0('Optimal threshold: ', round(cutoffOptMn,3),'\nApprox. AUC: ', round(auc_avg_approx,3)),
            nudge_x = 0.38, nudge_y = -0.08, size = 3.5) +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +  # diagonal
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

fs2b <- ggplot(data=accmeas) +
  geom_line(aes(x=cutoff,y=f1,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  geom_line(data=accmeas.mn, aes(x=cutoff, y = f1), color = "black", size = 0.8) +  # ROC curve average
  # geom_vline(xintercept=0.424, linetype="dashed", color="black") +
  geom_point(aes(x=cutoffOptMn, y=max_f1),
             color = "red", size = 3, shape = 19) +
  geom_text(aes(x=cutoffOptMn, y=max_f1),
            label = paste0('Optimal threshold: ', round(cutoffOptMn,3)),
            nudge_x = 0.0, nudge_y = 0.08, size = 3.5) +
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='Threshold', y='F1 Score', tag="B") +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

(fs2 <- ggarrange(fs2a,fs2b))

ggsave(fs2, file="../../figures/FigureS2_AUC_F1Max.png", dpi=300)

rm(fs2,fs2a,fs2b,accmeas_mn_sorted,auc_avg_approx)

```

Table S1: Performance metrics for the optimum cutoff value

Create a pretty table.

```{r}

library(flextable, quietly = T)

# Get the best F1 score for each model run
accmeas.best <- accmeas %>% 
  mutate(model = as.factor(model)) %>%
  group_by(model) %>% 
  top_n(1,f1) %>%
  ungroup() %>%
  mutate(model_iter = row_number()) %>%
  select(model,prSize,bgSize,tpr,precision,recall,f1,cutoff)

head(accmeas.best,10)

# Fix names and add units
names(accmeas.best) <- c("Model Seed",
                         "# of Presence",
                         "# of Background",
                         "True Positive Rate",
                         "Precision",
                         "Recall",
                         "F1-Score",
                         "Threshold")

# Set font name for table
fontname <- "Times New Roman"

# Create the flextable
(ft1 <- flextable(accmeas.best) %>%
 font(fontname = fontname, part = "all") %>%
 autofit() %>% fit_to_width(6.5))
print(ft1, preview = "docx")

# Write to a CSV
write_csv(accmeas.best, "../../figures/TableS1_Accuracy_MaxF1.csv")

```

Clean up!

```{r}

```
