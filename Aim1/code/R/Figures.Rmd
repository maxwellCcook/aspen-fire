---
title: "Figures"
output: html_notebook
root.dir: '~/Library/CloudStorage/OneDrive-Personal/mcook/aspen-fire'
---

```{r include=F}
source('setup.R')
```

# Study Region

```{r}
ggplot() +
  geom_sf(data=srme) +
  geom_sf(data=wrnf, fill="darkgrey") +
  geom_sf(data=blocks, fill=NA, lwd=0.4) +
  coord_sf(crs="EPSG:32613") +
  theme_light(11)
```

# Spectral Response and Phenological Characteristics

Load the Sentinel-2 annual time-series (2019). 

```{r}

# Spectral Response
ts <- read_csv('../../data/tabular/mod/results/s2msi_l2a_aspen_TSy2019.csv', 
               show_col_types = FALSE) %>% 
  select(-c(id,.geo,TCB,TCG,TCW)) %>%
  rename(NDVI705 = NDRE)

head(ts)

```

Tidy the time-series data.

1. Remove cloud-contaminated pixels,
2. Pivot the table to gather bands,
3. Generate mean/median/stdev of reflectance by image date,
4. Calculate weekly summaries

```{r}

# Filter out cloud-contaminated pixels based on the Cloud Score + values
# Reference:  https://medium.com/google-earth/all-clear-with-cloud-score-bd6ee2e2235e

tsp <- ts %>%
  filter(
    cs >= 0.8, # >= Cloud Score + contamination
  ) %>%
  # add the month as a column
  mutate(month = month(image_date, label=TRUE, abbr=TRUE)) %>%
  # Filter null values
  filter(complete.cases(.))

# Test using some visualizations

# NDVI705 scatter plot with trend line
tsp %>%
  group_by(image_date) %>%
  summarize(band = median(NDVI705)) %>%
  ggplot(aes(x=image_date,y=band)) +
  geom_point(size=0.8) +
  geom_smooth(method="loess") +
  labs(x="Image Date", y="NDRE") +
  theme_bw(11)

# NDVI705 box plot
ggplot(data=tsp, aes(x=NDVI705, y=month)) +
  geom_boxplot() +
  coord_flip() +
  labs(y="Image Date", x="NDRE") +
  theme_bw(11)

rm(ts)

```

Now pivot the table longer:

```{r}

tsp_ <- tsp %>%
  select(c(starts_with("B"),image_date,
           SLAVI,NDVI705,NDMI,ChlRE,IRECI,MCARI)) %>%
  group_by(image_date) %>%
  summarize_all(list(median)) %>%
  pivot_longer(
    cols = -c(image_date),
    names_to="band",
    values_to="reflectance"
  ) %>%
  # add a month and week label
  mutate(
    month = month(image_date, label=TRUE, abbr=TRUE),
    week = isoweek(image_date),
    biweek = cut.Date(image_date, breaks="2 week", labels=FALSE)
  )

head(tsp_, n=19)

rm(tsp)
gc()

```

Breakpoint analysis to identify significant shift in spectral signature throughout the year based on NDRE:

```{r}

# Isolate one of the vegetation indices (Normalized Difference Red-edge Index)
df <- tsp_ %>% 
  filter(band == "NDVI705") %>% 
  select(image_date,week,reflectance) %>%
  group_by(image_date,week) %>%
  summarize(reflectance = median(reflectance)) %>%
  ungroup()

# Create a weekly time-series object
df.ts <- ts(df$reflectance, frequency = 52)

# Implement the changepoint analysis based on NDRE
result <- changepoint::cpt.meanvar(df.ts, method="PELT")
bp.ind <- changepoint::cpts(result)

# Map breakpoints to dates
print("Breakpoint weeks:")
bp.dates <- df$week[bp.ind]
bp.dates

# Plot the result
plot(result)

rm(df, df.ts, result, bp.ind, bp.dates)

```

Perform the analysis by spatial block grid to get an idea of the variation in time-series breakpoints.

```{r}
results <- list()

for(block in unique(df$block_id)) {
    # Subset data for the block
    block_data <- df %>% filter(block_id == block)

    # Create time series (assuming weekly aggregation)
    block_ts <- ts(block_data$reflectance, frequency=52)

    # Perform breakpoint analysis
    block_result <- changepoint::cpt.meanvar(block_ts, method="PELT")

    # Store results with block identifier
    results[[block]] <- changepoint::cpts(block_result)
}

# Create an empty data frame to store breakpoint information
breakpoint_data <- data.frame(block_id = character(), breakpoint_week = integer())

# Loop through each block and add its breakpoints to the data frame
for(block in names(results)) {
    block_breakpoints <- results[[block]]
    block_data <- data.frame(block_id = rep(block, length(block_breakpoints)), 
                             breakpoint_week = block_breakpoints)
    breakpoint_data <- rbind(breakpoint_data, block_data)
}

# Convert the 'breakpoint_week' to actual dates
# This conversion depends on your specific date arrangement. Here's a basic example:
start_date <- as.Date("2019-01-02")  # Replace with your dataset's start date
breakpoint_data$breakpoint_date <- start_date + (breakpoint_data$breakpoint_week - 1) * 7

ggplot(breakpoint_data, aes(x = breakpoint_date, y = block_id, group = block_id)) +
    geom_line() +  # Optionally connect breakpoints in each block
    geom_point(size = 3) +  # Breakpoint markers
    theme_minimal() +
    labs(x = "Date", y = "Spatial Block") +
    theme(panel.grid.major.y = element_blank(),  # Removes horizontal grid lines
          panel.grid.minor.y = element_blank())
```

Plot of median daily observations:

```{r fig.height=5, fig.width=9}

# Reorder band factors
tsp_$band <- factor(tsp_$band, 
                   levels = c("B2","B3","B4","B5","B6","B7","B8","B8A","B11","B12",
                              "ChlRE","IRECI","NDMI","NDVI705","SLAVI","MCARI"))

tsp_ %>%
  filter(str_detect(band,"B")) %>%
  ggplot(aes(x=image_date,y=reflectance ,color=factor(band))) +
  geom_line(linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  labs(x="Acquisition Date",y="Reflectance",color="S2 MSI Band") +
  theme_bw(14) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.text = element_text(size=10),
        legend.title = element_text(size=11))
```

## Figure 3: Spectral Response of Aspen Forest Presence Data

Gather the seasonal composite start and end dates:

```{r}
# Summer
(start_summer <- week(as.Date("2019-05-25")))
(end_summer <- week(as.Date("2019-08-13")))
# Autumn
(start_autumn <- week(as.Date("2019-09-02")))
(end_autumn <- week(as.Date("2019-11-14")))
```

Generate the weekly median reflectance.

```{r warning=F, message=F, fig.height=5, fig.width=9}

# List for band colors

band_colors <- c(
  "B2"  = "#1E90FF",  # Blue: Dodger Blue
  "B3"  = "#00FF7F",  # Green: Spring Green
  "B4"  = "#FF0000",  # Red: Pure Red
  "B5"  = "#FFA07A",  # Red Edge: Light Salmon
  "B6"  = "#FF8C00",  # NIR: Dark Orange
  "B7"  = "#D2691E",  # NIR: Chocolate
  "B8"  = "#FFD700",  # NIR: Gold
  "B8A" = "#B8860B",  # NIR: Dark Goldenrod
  "B11" = "#008B8B",  # SWIR: Dark Cyan (dark shade of teal)
  "B12" = "#800080"   # SWIR: Purple
)


# Group by week, calculate the mean, plot

f3a <- tsp_ %>%
  filter(str_detect(band,"B")) %>%
  group_by(band,week) %>%
  summarize(refl = mean(reflectance)) %>%
  ggplot(aes(x=week,y=refl,color=factor(band))) +
  geom_line(linewidth=0.6) +
  scale_color_manual(values = band_colors) +
  labs(x="Acquisition Week",y="Reflectance",color=NULL) +
  theme_bw(11) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8),
        legend.position = c(0.2,0.95),
        legend.direction = "horizontal",
        legend.background = element_rect(fill="white", color="black"),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial")) +
  annotate('rect', xmin=start_summer, xmax=end_summer, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  annotate('rect', xmin=start_autumn, xmax=end_autumn, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  geom_vline(xintercept=start_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=start_autumn, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_autumn, linetype="dotted", lwd=0.8)

f3a
```

## Figure 1B: Time-series charts of the spectral indices:

```{r message=F, warning=F}

# All bands

# Calculate the maximum reflectance for each band
max_refl_band <- tsp_ %>%
  group_by(band) %>%
  summarize(max_refl = max(reflectance))

# Now create your plot
tsp_ %>%
  group_by(band, week) %>%
  summarize(refl = mean(reflectance), .groups = 'drop') %>%
  ggplot(aes(x = week, y = refl, group = 1)) +
  geom_line() +
  geom_rect(data = max_refl_band, aes(xmin=start_summer, xmax=end_summer, ymin=0, ymax=max_refl), alpha=.3, fill='gray',
            inherit.aes = FALSE) +
  geom_rect(data = max_refl_band, aes(xmin=start_autumn, xmax=end_autumn, ymin=0, ymax=max_refl), alpha=.3, fill='gray',
            inherit.aes = FALSE) +
  geom_vline(xintercept = start_summer, linetype = "dotted", lwd = 0.8) +
  geom_vline(xintercept = end_summer, linetype = "dotted", lwd = 0.8) +
  geom_vline(xintercept = start_autumn, linetype = "dotted", lwd = 0.8) +
  geom_vline(xintercept = end_autumn, linetype = "dotted", lwd = 0.8) +
  facet_wrap(. ~ band, scales = "free_y") +
  theme_minimal() +
  theme(axis.title.y = element_text(size = 8, face = "italic",
                                    margin = unit(c(0, 0.4, 0, 0), "cm")),
        axis.title.x = element_text(size = 8, face = "italic",
                                    margin = unit(c(0.4, 0, 0, 0), "cm")),
        axis.text = element_text(size = 7),
        strip.text.x = element_text(size = 8))

# Spectral indices

max_refl_band_vi <- max_refl_band %>%
  filter(!str_detect(band,"B"))

f3b <- tsp_ %>%
  filter(!str_detect(band,"B")) %>%
  group_by(band,week) %>%
  summarize(refl = mean(reflectance)) %>%
  ggplot(aes(x=week, y=refl, group=1)) +
  geom_line(linewidth=0.6) +
  labs(x="Acquisition Week",y="") +
  geom_rect(data = max_refl_band_vi, aes(xmin = start_summer, xmax = end_summer, ymin = 0, ymax = max_refl), alpha = .3, fill = 'gray',
            inherit.aes = FALSE) +
  geom_rect(data = max_refl_band_vi, aes(xmin = start_autumn, xmax = end_autumn, ymin = 0, ymax = max_refl), alpha = .3, fill = 'gray',
            inherit.aes = FALSE) +
  geom_vline(xintercept=start_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=start_autumn, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_autumn, linetype="dotted", lwd=0.8) +
  facet_wrap(. ~ band, scales = "free") +
  theme_light(11) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3b

rm(max_refl_band,max_refl_band_vi)

```

## Figure 3C: Boxplot of seasonal composites:

```{r}

cols <- c(
  "Summer" = "#87CEEB", 
  "Autumn" = "#DAA520"
)

seasonal <- tsp_ %>%
  mutate(season = if_else(week>=22&week<=37,"Summer","na"),
         season = if_else(week>=37&week<=48,"Autumn",season)) %>%
  filter(season!="na")

seasonal$season <- factor(seasonal$season, levels = c("Summer","Autumn"))
  
f3c <- seasonal %>%
  filter(str_detect(band,"B")) %>%
  ggplot(aes(x=band,y=reflectance,fill=season)) +
  geom_boxplot(outlier.size = 0.5, outlier.color = "grey30") +
  scale_fill_manual(values = cols) +
  theme_bw(12) +
  labs(x="Sentinel-2 MSI Band",y="Reflectance",fill="Season: ") +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.position = "none",
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3c

```

## Figure 1D: Seasonal differences in the spectral indices

```{r}

f3d <- seasonal %>%
  filter(!str_detect(band,"B")) %>%
  ggplot(aes(y=reflectance)) +
  geom_boxplot(aes(fill=season)) +
  scale_fill_manual(values = cols) +
  facet_wrap(. ~ band, scales = "free") +
  theme_bw(12) +
  labs(fill="Season",y="") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        # legend.position = c(0.85,0.2),
        legend.position = "bottom",
        legend.title = element_text(size=12),
        legend.text = element_text(size=12),
        legend.spacing.y = unit(1.5, "cm"),
        legend.spacing.x = unit(0.5, 'cm'),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3d

```

Combine the plots:

```{r fig.width=7.5, fig.height=10, message=F, warning=F}

# Arrange in a multi-panel plot

f3 <- ggarrange(f3a,f3b,f3c,f3d, nrow=2,ncol=2, widths=c(1, 0.75), labels = c("A", "B", "C", "D"))
f3

# Save it out

ggsave(f3, file = "../../figures/Figure3_SpectralResponse.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Version 2:

```{r fig.width=14, fig.height=8}

f3_ <- ggarrange(f3a,ggarrange(f3c,f3d,nrow=1,ncol=2),
                  ncol=1,widths=c(1, 0.75),
                  labels = c("A", "B", "C"))
f3_

ggsave(f3_, file = "../../figures/Figure3_SpectralResponse_v2.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Clean up the time-series / spectral response data:

```{r}
rm(f3,f3a,f3b,f3c,f3d,seasonal,band_colors,cols,end_autumn,end_summer,start_autumn,start_summer,tsp_)
gc()
```

# Model Selection and Accuracy Assessment

Load the accuracy assessment results for the best performing model (the final model in GEE). This represents the most parsimonious model (multicollinear bands removed and feature selection in rfUtilities). See the "accmeas.R" script.

```{r}
accmeas <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_accmeas.csv',
                    show_col_types = FALSE)
opt_thresh <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_opt_thresh.csv',
                    show_col_types = FALSE)

glimpse(accmeas)
head(opt_thresh)

```

## Figure 4AB. Classification Scenarios

```{r fig.width=6.5, fig.height=3.5, message=F, warning=F}

scenarios <- read_csv("../../data/tabular/mod/results/scenarios/rf_accmets_scenarios.csv", show_col_types = FALSE)

# Read in the best performing model results to append
final_model <- opt_thresh %>%
  mutate(Feature_Set = "Final_Model") %>%
  rename(F1 = f1) %>%
  select(Feature_Set,F1)

scenarios <- bind_rows(scenarios,final_model)
head(scenarios)

# Box plot version
ggplot(data=scenarios, aes(x=reorder(Feature_Set,F1),y=F1)) +
  geom_boxplot(outlier.size=0.6, fill="lightblue") +
  ylim(0,1) +
  labs(x="Classification Scenario",y="F1-score", tag="A") +
  theme_bw(10) +
  theme(
        plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
        axis.title.y = element_text(size=10,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=10,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=9),
        strip.text.x = element_text(size = 10),
        axis.text.x = element_text(angle = 45, hjust=1),
        text = element_text(family = "Arial"))

# Calculating the means and standard errors for F1-scores
# Plot as a bar chart with standard errors
f4a <- scenarios %>%
  group_by(Feature_Set) %>%
  summarise(
    Mean = mean(F1),
    SE = sd(F1) / sqrt(n())
  ) %>%
  # Plotting the bar chart with error bars
  ggplot(aes(x=reorder(Feature_Set, Mean), y=Mean)) +
    geom_bar(stat="identity", fill="lightblue", width=0.75) +
    geom_errorbar(aes(ymin=Mean-SE, ymax=Mean+SE), width=0.2) +
    ylim(0, 1) +
    labs(x="Classification Scenario", y="F1-score") +
    theme_bw(base_size = 10) +
    theme(
      plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
      axis.title.y = element_text(size=10, face="italic", margin = unit(c(0,0.4,0,0), "cm")),
      axis.title.x = element_text(size=10, face="italic", margin = unit(c(0.4,0,0,0), "cm")),
      axis.text = element_text(size=9),
      strip.text.x = element_text(size = 10),
      axis.text.x = element_text(angle = 45, hjust=1),
      text = element_text(family = "Arial")
    )
f4a

# Save out
ggsave(f4a, file = "../../figures/Figure4A_Class_Scenarios.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

## Table X. Average F1-score and other metrics for the classification scenarios and the final model

```{r}
# Read in the best performing model results to append
final_model <- opt_thresh %>%
  mutate(Feature_Set = "Final_Model") %>%
  rename(F1 = f1) %>%
  select(Feature_Set,F1)

scenarios_ <- bind_rows(scenarios,final_model)
head(scenarios_)

# Create the final table
df <- scenarios_ %>%
  group_by(Feature_Set) %>%
  summarize(
    F1_mn = mean(F1),
    F1_sd = sd(F1)
  ) %>%
  mutate(
    n_features = if_else(Feature_Set == "Summer_S1" | Feature_Set == "Winter_S1", 5, 0),
    n_features = if_else(Feature_Set == "Summer_S1_GLCM" | Feature_Set == "Winter_S1_GLCM", 13, n_features),
    n_features = if_else(Feature_Set == "Summer_Winter_S1", 23, n_features),
    n_features = if_else(Feature_Set == "Summer_S2" | Feature_Set == "Autumn_S2", 13, n_features),
    n_features = if_else(Feature_Set == "Summer_S2_VI" | Feature_Set == "Autumn_S2_VI", 19, n_features),
    n_features = if_else(Feature_Set == "Summer_Autumn_S2", 35, n_features),
    n_features = if_else(Feature_Set == "Combined_S1_S2", 55, n_features),
    n_features = if_else(Feature_Set == "Final_Model", 17, n_features)
  )

head(df,12)

# Create a tidy table

# Set font name for table
fontname <- "Times New Roman"

# Clean up extra rows and digits
cleaned <- df %>%
 mutate_if(is.double, ~ round(., digits = 4)) %>%
 # Sort from fastest to slowest
 arrange(desc(F1_mn))

# Fix names and add units
names(cleaned) <- c("Feature Set","Mean F1-score","Standard Deviation","Number of Features")

# Create the flextable
ft <- flextable::flextable(cleaned) %>%
  flextable::font(fontname = fontname, part = "all") %>%
  flextable::autofit() %>% 
  flextable::fit_to_width(7.5)
ft
print(ft, preview = "docx")

# rm(scenarios,df)
```

## Figure 4CD. Accuracy Assessment of the Best Performing Model

The optimum cutoff value for classification is defined as the average cutoff across folds at which the F1-score is maximized. We can see the optimum cutoff value and how it corresponds with F1-score and the AUC-PR curve.

```{r warning=F, fig.width=3, fig.height=3}
paste0("Optimum cutoff for classification: ",round((opt_cutoff <- mean(opt_thresh$cutoff_f1)),3))
paste0("Average F1-score: ",round((f1max <- max(opt_thresh$f1)),3))

# AUC-PR Curve (approximation)

ggplot(data=accmeas) +
  geom_line(aes(x=fpr,y=tpr,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='False Positive Rate', y='True Positive Rate') +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +  # diagonal
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

f5b <- ggplot(data=accmeas) +
  geom_line(aes(x=cutoff,y=f1,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  # geom_vline(xintercept=0.50, linetype="dashed", color="black") +
  geom_point(aes(x=opt_cutoff, y=f1max),
             color = "black", size = 3, shape = 19) +
  geom_text(aes(x=opt_cutoff, y=f1max),
            label = paste0('Optimal threshold: ', round(opt_cutoff,3)),
            nudge_x = 0.0, nudge_y = 0.08, size = 3.5) +
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='CLassification Threshold', y='F1 Score') +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))
f5b

# Save out
ggsave(f4a, file = "../../figures/Figure4A_Class_Scenarios.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Using the optimum cutoff value, we can classify the test data and calculate the Precision, Recall, and F1-score. 

```{r}
testPart <- "../../data/tabular/mod/results/best_model/southern_rockies_test_probs_n55.csv"
# Assign the classification label based on the optimum cutoff
testData <- read_csv(testPart, show_col_types=FALSE) %>%
  rename(gee_id = `system:index`,
         TrueLabel = label) %>%
  dplyr::select(-.geo) %>%
  mutate(probability = probability*0.001, # scale back
         ClassLabel = if_else(probability >= opt_cutoff, 1, 0)) %>%
  group_by(seed) %>%
  summarize(
    tp = sum(TrueLabel == 1 & ClassLabel == 1),
    tn = sum(TrueLabel == 0 & ClassLabel == 0),
    fp = sum(TrueLabel == 0 & ClassLabel == 1),
    fn = sum(TrueLabel == 1 & ClassLabel == 0),
    accuracy = (tp + tn) / (tp + tn + fp + fn),
    precision = tp / (tp + fp),
    recall = tp / (tp + fn),
    f1 = 2 * (precision * recall) / (precision + recall),
    .groups = 'drop' # This ensures that the result is a single data frame, not a grouped one
  )
head(testData,10)

# First, get the overall F1/MCC for the classification
print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
paste0("Average F1-score for the best performing model at the optimum cutoff: ",mean(testData$f1))
paste0("Range of F1-scores: ",range(testData$f1))
paste0("StDev of F1-scores: ",sd(testData$f1))
summary(testData$f1)

# rm(testPart,testData)
```

Plot the model accuracy results for the optimum threshold.

Figure 4A: Model Accuracy (F1 and OA)

```{r message=F, warning=F, fig.height=3.5, fig.width=6.5}

cols <- c("F1 Score"="#1f78b4","Overall Accuracy"="gray75")

testData <- testData %>%
  mutate(Fold = as.numeric(factor(seed, levels = sort(unique(seed)))))

f4b <- ggplot(data=testData) +
  geom_hline(yintercept=mean(testData$precision),linetype="dashed",color="gray85") +
  geom_hline(yintercept=mean(testData$recall),linetype="dashed",color="gray45") +
  geom_hline(yintercept=mean(testData$f1),linetype="dashed",color="#1f78b4") +
  # Plot the Precision and Recall
  geom_line(aes(x=factor(Fold),y=precision,group=1),color="gray65") +
  geom_line(aes(x=factor(Fold),y=recall,group=1),color="gray35") +
  # Plot the F1-score
  geom_line(aes(x=factor(Fold),y=f1,group=1),color="#1f78b4") +
  geom_point(aes(x=factor(Fold),y=f1,size=f1), color="#1f78b4") +
  scale_size(range = c(3,6)) +
  coord_cartesian(ylim = c(0.85, 1)) +
  labs(x="Fold", y="Score", tag="B") +
  # annotate("text", x = 2.6, y = 0.88, label = paste("Average F1 Score: ", round(mean(testData$f1), 2))) +
  theme_bw() +
  guides(size="none") +
  theme(
        plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        text = element_text(family = "Arial"))
f4b

ggsave(f4b, file = "../../figures/Figure4A_Best_Model_Acc_F1.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

```{r fig.width=7.5, fig.height=7.5}
arr4 <- ggarrange(f4a,ggarrange(f4b,f5b, ncol=2, nrow=1, align='h'), nrow=2, align="h")
arr4
ggsave(arr4, file = "../../figures/Figure4_ModelSel_BestModel_ThreshOpt.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```

## Figure 6: Feature importance from the best model

```{r}
# Feature Importance
ftr_imp <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_feature_imps_n55.csv',
                    show_col_types = FALSE)
glimpse(ftr_imp)
```

```{r message=F, warning=F, fig.width= 6.5, fig.height=3.5}

# Tidy the data frame
df.imp <- ftr_imp %>% 
  select(-c(.geo,`system:index`)) %>%
  rename(model = seed) %>%
  mutate(model = as.factor(model))

# Pivot longer
df.imp.p <- df.imp %>%
  pivot_longer(cols = -model) %>%
  rename(importance = value,
         band = name) %>%
  mutate(season = if_else(str_detect(band,"_autumn"), "Autumn S2", "Summer S2"),
         season = if_else(str_detect(band,"_winter"), "Winter S1", season),
         season = if_else(str_detect(band,"VV_summer"), "Summer S1", season),
         season = if_else(str_detect(band,"VH_summer"), "Summer S1", season))
glimpse(df.imp.p)

# Grab the top 20 over all model runs
top <- df.imp.p %>%
  group_by(band) %>%
  summarize(median = median(importance)) %>%
  ungroup()
top <- head(arrange(top,desc(median)), n = 10)

# Color palette

cols <- c(
  "Summer S2" = "#87CEEB", 
  "Autumn S2" = "#DAA520",
  "Winter S1" = "gray29",
  "Summer S1" = "gray89"
)

# Boxplot

# %>% filter(band %in% top$band)
f6 <- ggplot(data=df.imp.p %>% filter(band %in% top$band), 
              aes(x=reorder(band,importance), fill=season)) +
  geom_boxplot(aes(y=importance), position = position_dodge(0.5)) +
  scale_fill_manual(values = cols, 
                    labels = c("Autumn S2","Summer S1","Summer S2","Winter S1")) +
  coord_flip() +
  theme_bw(11) +
  theme(axis.text.x = element_text(size=11),
        axis.text.y = element_text(angle = 0, vjust=0, size=11),
        axis.title = element_text(size=11,face="italic"),
        legend.position = "bottom",
        legend.justification = c(1.2,0.5), # Left-aligns the legends
        legend.text = element_text(size=11),
        text = element_text(family = "Arial"),
        plot.margin=unit(c(0.5,0.5,0.5,0.5),"cm")) +
  labs(x="Feature", y="Importance", fill="Season: ")
f6

ggsave(f6, file = "../../figures/Figure6_FeatureImportance_top10.png",
       dpi=300, bg="white") # adjust dpi accordingly

```

Clean up!

```{r}
rm(list = ls.str(mode = 'numeric'))
rm(accmeas,accmeas.best,accmeas.mn,accmeas.s,df.imp,
   df.imp.p,f4,f4a,f4b,f6,ftr_imp,top,cols,arr4,cleaned,
   df,f5b,final_model,ft,opt_thresh,scenarios,scenarios_,testData)
gc()
```

# Spatial Agreement and Landscape Patch Dynamics

## Table X: Accuracy of the reference datasets based on test data

```{r message=F}
ref_acc <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_ref_accmeas.csv',
                    show_col_types = F)
head(ref_acc)

# Create a tidy table
df <- ref_acc %>%
  filter(metric == "Predicted") %>%
  select(reference,precision, recall, f1_score)
head(df)

# Create a tidy table

# Set font name for table
fontname <- "Times New Roman"

# Clean up extra rows and digits
cleaned <- df %>%
 mutate_if(is.double, ~ round(., digits = 4)) %>%
 # Sort from fastest to slowest
 arrange(desc(f1_score))

# Fix names and add units
names(cleaned) <- c("Data Source","Precision","Recall","F1-score")

# Create the flextable
ft <- flextable::flextable(cleaned) %>%
  flextable::font(fontname = fontname, part = "all") %>%
  flextable::autofit() %>% 
  flextable::fit_to_width(7.5)
ft
print(ft, preview = "docx")

rm(df,ref_acc)
```

## Figure 7: Spatial Agreement (pixel-based)

```{r}
aggr.sr <- aggr.sr %>%
  mutate(source = if_else(source == "usfs_treemap16_balive_int_bin_srme_10m", "USFS TreeMap", source))
glimpse(aggr.sr)
```

Remove blocks with little to no aspen forest cover. First look at the distribution of aspen forest cover across spatial blocks.

```{r warning=F, message=F}

# Plot the distribution of aspen area
blocks %>%
  st_set_geometry(NULL) %>%
  as_tibble() %>%
  mutate(s2aspen_sum = as.integer(s2aspen_sum)) %>%
  ggplot(aes(x=s2aspen_sum)) +
  scale_x_continuous(trans="log") +
  geom_histogram() +
  theme_minimal(12)

# Filter out non-aspen blocks
blocks_aspen <- blocks %>%
  filter(s2aspen_sum > 100000)

```

```{r message=F, fig.width = 6.5, fig.height = 3.25}

flabs <- c(precision = "Precision", recall = "Recall", f1 = "F1-score")

# Reshape the agreement table for plotting facet wrap

# Southern Rockies (by block)
aggr.sr.m <- reshape2::melt(
  aggr.sr, id.vars = c("blocksize", "source", "region", "block"), 
  measure.vars = c("precision", "recall", "f1"), variable.name = "statistic"
) %>%
  na.omit() %>%
  filter(blocksize == 1,
         block %in% blocks_aspen$id)

# White River NF
aggr.wr.m <- reshape2::melt(
  aggr.wr, id.vars = c("blocksize", "source", "region"), 
  measure.vars = c("precision", "recall", "f1"), variable.name = "statistic"
) %>%
  na.omit() %>%
  filter(blocksize == 1)

# Facet wrap plot of the statistics by block group

f7 <- ggplot(data=aggr.sr.m, aes(x=factor(blocksize), y=value, fill=factor(source))) +
  geom_boxplot(position = position_dodge()) + 
  scale_fill_viridis_d(labels=c("LANDFIRE EVT","USFS TreeMap","USFS ITSP"), name="",
                       breaks=c("LANDFIRE EVT", "USFS TreeMap", "USFS ITSP")) +
  facet_wrap(~statistic, labeller = labeller(statistic = flabs)) +
  theme_bw(11) +
  theme(legend.position = "bottom",
        legend.box = "vertical",
        legend.justification = c(0.5,0.5), # Left-aligns the legends
        legend.spacing.y = unit(-5, "pt"), # Adjusts the gap between the legends
        # legend.text = ggtext::element_markdown(halign = 0), # This aligns each individual legend's text to the left
        axis.title.x=element_blank(),  # Remove x axis title
        axis.text.x=element_blank(),   # Remove x axis text
        axis.ticks.x=element_blank(),  # Remove x axis ticks
        axis.title = element_text(size=11,face="italic")) +
        # text = element_text(family = "Times New Roman")) +
  labs(x="Blocksize", y="Value")

# Add the WRNF statistics
f7 <- f7 +
  geom_point(data=aggr.wr.m, aes(x=factor(blocksize), y=value, group=factor(source)),
             position=position_dodge(0.75), shape=18, size=4, color="white") +
  # Then add the actual point in black
  geom_point(data=aggr.wr.m, aes(x=factor(blocksize), y=value, group=factor(source)),
             position=position_dodge(0.75), shape=18, size=3, color="black") +
  scale_shape_manual(name="Subregion", values=c("White River NF" = 8)) +
  guides(
    fill=guide_legend(override.aes=list(shape=NA)), # No shape in the fill legend
    shape=guide_legend(title=" ", override.aes=list(color="black")) # Shape legend for Subregion
  )
f7

# Save out
ggsave(f7, file = "../../figures/Figure7_Agreement_Box.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```
```{r}
# Add a spatial map of statistics by blocks
blocks_ <- blocks %>%
  mutate(id = as.numeric(id)-1) %>%
  rename(block = id) %>%
  left_join(aggr.sr, by="block") %>%
  pivot_longer(cols = c(precision, recall, f1), names_to = "statistic", values_to = "value") %>%
  na.omit()

f7b <- ggplot(data = blocks_) +
  geom_sf(aes(fill = value)) +
  geom_sf(data=srme, fill=NA, color="grey20", linewidth=0.4) +
  facet_grid(source ~ statistic) +
  scale_fill_viridis_c(option = "C") + # Use a continuous color scale
  theme_void() +
  theme(
    strip.text.x = element_text(size = 10),
    legend.position = "bottom"
  ) +
  guides(fill = guide_colourbar(direction = "horizontal", barwidth = 10, barheight = 0.60,
                                ticks=F, title.position = "left"),
         label.theme = element_text(angle = 0, size = 9)) +
  labs(fill="", tag="B")
f7b

# Save out
ggsave(f7b, file = "../../figures/Figure7_Agreement_Maps.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```

Join the two plots.

```{r}

f7 <- f7 + theme(plot.margin = unit(c(0.5, 10, 0.5, 0.5),"mm")) # Add right margin to the left plot
f7b <- f7b + theme(plot.margin = unit(c(0.5, 0.5, 10, 0.5),"mm")) # Add left margin to the right plot

arr7 <- ggarrange(f7, f7b, ncol=2, align="h", widths = c(1.5,1))
arr7

# Save out
ggsave(arr7, file = "../../figures/Figure7_Agreement_Box_Maps_Arr.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```


```{r}

brewer.pal(n=5,"Set1")

cols <- c("#4DAF4A", "#984EA3", "#FF7F00")

glimpse(ref.global)

# # Get an average f1 score table
# f1mn <- ref.global %>%
#   group_by

# Add a statistics column for legend (could do this for F1 too ...)
ref.global.m <- reshape2::melt(
  ref.global, id.vars = c("blocksize", "source", "region"), 
  measure.vars = c("prec", "rec"), variable.name = "statistic"
)

glimpse(ref.global.m)

f7a <- ggplot(data=ref.global.m) +
  geom_line(aes(x=blocksize,y=value,color=factor(source), linetype=statistic), linewidth=0.6) +
  geom_point(data=ref.global, aes(x=blocksize, y=f1, color=source)) +
  scale_x_continuous(breaks=c(1,3,5,7,9)) +
  scale_linetype_manual(values = c("prec" = "dotted", "rec" = "solid"), name="Statistic: ",
                        labels=c("Precision","Recall")) +
  facet_wrap(~region, scales = "fixed") +
  scale_color_manual(values=cols, labels=c("LANDFIRE EVT","USFS TreeMap","USFS ITSP"), name="Source: ") +
  theme_light(14) +
  ylim(0,1) +
  theme(legend.position = "top",
        legend.box = "vertical",
        legend.justification = c(0.5,0.5), # Left-aligns the legends
        legend.spacing.y = unit(-10, "pt"), # Adjusts the gap between the legends
        legend.text = ggtext::element_markdown(halign = 0), # This aligns each individual legend's text to the left
        axis.title = element_text(size=12,face="italic"),
        text = element_text(family = "Arial")) +
  labs(x="Blocksize (pixels)",y="Value")
  
f7a

ggsave(f7a, file = "../../figures/Figure7_Global_PrecRec_Agreement.png", dpi=300)

```

Focal accuracy:

```{r message=F}

# ref.focal$refbudens <- log(1 + ref.focal$tp + ref.focal$fn)
# 
# ggplot(ref.focal %>% filter(region=="SRME"), aes(x = prec, y = rec, color = refbudens)) +
#    geom_point(size = 2, alpha = 0.9) +
#    scale_color_viridis_c() +
#    facet_grid(rows = vars(geog_scale), cols = vars(blocksize), scales = "fixed") +
#    theme_light() +
#    labs(
#       title = 'Spatially explicit accuracy: Precision (x) vs. Recall (y)',
#       subtitle = 'for multiple analytical units and spatial support levels',
#       color = 'refbudens',
#       x = 'Precision',
#       y = 'Recall'
#    ) +
#    coord_cartesian(xlim = c(0, 1), ylim = c(0, 1)) +
#    theme(legend.position = "bottom")

```

Join the two plots:

```{r}
# f7 <- ggarrange(global_precrec,focal.prec,focal.rec,nrow=1,labels=c("A","B","C"))
# f7
# ggsave(f7, file="../../figures/Figure7_Global_Focal_Agreement.png", dpi=300)
```

Clean up! 

```{r}
rm(ref.global,ref.global.m,f7a,f7b,f7,ref.focal)
gc()
```

## Figure 8: Landscape Patch Dynamics

```{r}
# List csv file paths for the Southern Rockies
maindir <- '../../data/tabular/results/ls_metrics'
grids_list <- list.files(path = paste0(maindir), 
                         pattern = "\\.csv$", 
                         full.names = TRUE, 
                         recursive = TRUE)
```

```{r}
unique(factor(patch_metrics$source))
summary(patch_metrics)
```

Calculate some grouped statistics (to compare with the class metrics results)

```{r message=F, warning=F, fig.height=8, fig.width=8}

# Also create a grouped summary
(patch.summary <- patch_metrics %>%
  group_by(source,region) %>%
  summarize(area_md = median(area), # convert to hectares
            area_mn = mean(area),
            area_sum = sum(area),
            perim_md = median(perimeter),
            perim_mn = mean(perimeter),
            par_md = median(perimeter_area_ratio),
            par_mn = mean(perimeter_area_ratio),
            si_md = median(shape_index),
            si_mn = mean(shape_index)) %>%
  ungroup())

(patch.long <- patch.summary %>%
  pivot_longer(cols = c(contains("_")),
               names_to = "metric",
               values_to = "value"))

patch.long$source <- factor(patch.long$source,levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))

(ggplot(data = patch.long, aes(x=source, y=value, fill=region)) +
    geom_bar(stat="identity", position="dodge", width=0.7) +
    facet_wrap(~metric, scales="free") + 
    theme_minimal(14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
    text = element_text(family = "Arial")))

(f8s <- ggplot(data = patch.long, aes(x=source, y=value, fill=region)) +
    geom_bar(stat="identity", position="dodge", width=0.7) + 
    theme_minimal(14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
    text = element_text(family = "Arial")))

```

Grab some summary statistics on the patch dynamics:

```{r}

a <- patch.long %>% filter(region=="SRME",metric=="area_mn",source=="Aspen10m")
b <- patch.long %>% filter(region=="SRME",metric=="area_mn",source=="LFEVT")

print("Difference in mean patch size for the SRME: ")
((b$value-a$value)/b$value)*100

a <- patch.long %>% filter(region=="WRNF",metric=="area_mn",source=="Aspen10m")
b <- patch.long %>% filter(region=="WRNF",metric=="area_mn",source=="LFEVT")

print("Difference in mean patch size for the WRNF: ")
((b$value-a$value)/b$value)*100

print("~~~~~~~~~~~~~~~~")

print("Difference in mean patch size for the SRME: ")
((b$value-a$value)/b$value)*100

(c <- patch.long %>% filter(metric=="area_md",source=="Aspen10m"))
(d <- patch.long %>% filter(metric=="area_md",source=="LFEVT"))

print("Mean and median patch sizes: ")
paste0("Aspen10m mean: ",a$value)
paste0("LFEVT mean: ",b$value)
paste0("Aspen10m median: ",c$value)
paste0("LFEVT mean: ",d$value)



print("Difference in median area: ")
((d$value-c$value)/d$value)*100

print("Mean Perimeter area ratio: ")
(a <- patch.long %>% filter(metric=="par_mn",source=="Aspen10m"))
(b <- patch.long %>% filter(metric=="par_mn",source=="LFEVT"))

print("Difference in PAR: ")
((b$value-a$value)/b$value)*100

rm(a,b,c,d)
```

Boxplot as facet wrap for patch metrics:

```{r fig.height=5, fig.width=10}

brewer.pal(n=5,"Set1")

cols <- c("#005a32","#a1d99b")

(df <- patch_metrics %>%
  # mutate(area_ha = area*100) %>%
  select(-c(X,index,shape_index)) %>%
  pivot_longer(contains(c("area","perimeter_area_ratio"))) %>%
  arrange(source, desc(value)) %>%
  mutate(name = as.character(name),
         name = recode(name,
                       "area" = "Patch Size (ha)",
                       "perimeter_area_ratio" = "Perimeter/Area Ratio")))

df$source <- factor(df$source,
                    levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))
 
(f8a <- ggplot(data=df, aes(y = value, x = factor(source), fill = factor(region))) +
  geom_boxplot(outlier.size = 0.2) +
  scale_y_continuous(trans="log10",labels=label_number_si(accuracy = 1)) +
  scale_fill_manual(values=cols) +
  facet_wrap(~name, scales = "free_y", nrow=1) +
  labs(x="\nData Source",y="Value",title="Patch Metrics", fill="Region: ") +
  theme_light(12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=11),
        axis.text.y = element_text(angle = 0, vjust=0.1, size=11),
        axis.title.y = element_text(size=12, face="italic", vjust=1),
        axis.title.x = element_text(size=12, face="italic", vjust=-1),
        plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm"),
        legend.position="top",
        legend.spacing.x = unit(0.5,"cm"),
        text = element_text(family = "Arial")))

ggsave(f8a, file = "../../figures/Figure8A_patch_metrics.png", dpi = 300) # adjust dpi accordingly

```

Plot class metrics as facet wrap:

```{r fig.height=5, fig.width=10, message=F}

# Calculate area in square meters
srme_area_km2 <- st_area(srme) / 1e6
wrnf_area_km2 <- st_area(wrnf) / 1e6

(df <- class_metrics %>%
  mutate(total_area = total_area*0.01,
         prop_area = if_else(region=="SRME", as.double((total_area/srme_area_km2*100)), 0.0),
         prop_area = if_else(region=="WRNF", as.double((total_area/wrnf_area_km2*100)), prop_area)) %>%
  select(-c(X)) %>%
  pivot_longer(cols = c(contains("_")),
               names_to = "metric",
               values_to = "value") %>%
  mutate(metric = as.character(metric),
         metric = recode(metric,
                         "n_patch" = "Number of Patches",
                         "patch_den" = "Patch Density",
                         "total_area" = "Total area (km2)",
                         "prop_area" = "Proportion of Area")))

df$source <- factor(df$source, levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))
head(df)

(f8b <- ggplot(data=df, aes(y=value, x=factor(source), fill=factor(region))) +
  geom_bar(stat="identity", position="dodge", width=0.7) +
  scale_y_continuous(labels=scales::label_number_si(accuracy = 1)) +
  scale_fill_manual(values=cols) +
  labs(x="", y="Value", title="Landscape Metrics", fill="Region: ") +
  theme(axis.title.x = NULL) +
  facet_wrap(~metric, scales = "free_y") +
  theme_light(12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=11),
        axis.text.y = element_text(angle = 0, vjust=0.1, size=11),
        axis.title.y = element_text(size=12, face="italic", vjust=0.5),
        axis.title.x = element_text(size=12, face="italic", vjust=-0.5),
        plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm"),
        legend.position = "top",
        legend.spacing.x = unit(0.5,"cm"),
        text = element_text(family = "Arial")))

ggsave(f8b, file = "../../figures/Figure8B_landscape_metrics.png", dpi = 300) # adjust dpi accordingly

```

```{r fig.width=10, fig.height=10}
(arr <- ggarrange(f8b,f8a,nrow=2,ncol=1,labels=c("A","B"), common.legend = T))
ggsave(arr, file="../../figures/Figure8_Landscape_Patch_Metrics.png", dpi=300)
```

The 10-m aspen classification identified Xx more patch than reference images:

```{r}

print("% Difference in number of patches across the Southern Rockies: ")
a <- df %>% filter(region=="SRME",metric=="Number of Patches",source=="Aspen10m")
b <- df %>% filter(region=="SRME",metric=="Number of Patches",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("% Difference in number of patches across the White River NF: ")
a <- df %>% filter(region=="WRNF",metric=="Number of Patches",source=="Aspen10m")
b <- df %>% filter(region=="WRNF",metric=="Number of Patches",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("~~~~~~~~~~~~~")

print("~~~~~~~~~~~~~")

print("% Difference in patch density: ")
a <- df %>% filter(metric=="Patch Density",source=="Aspen10m")
b <- df %>% filter(metric=="Patch Density",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("% Difference in total area:")
a <- df %>% filter(metric=="Total area (km2)",source=="Aspen10m")
aa <- df %>% filter(metric=="Total area (km2)",source=="Aspen30m")
b <- df %>% filter(metric=="Total area (km2)",source=="LFEVT")
((b$value-a$value)/b$value)*100
((b$value-aa$value)/b$value)*100

rm(a,aa,b)

```


# Supplemental

Figure S1: Phenology across the SRME study region

```{r}

# Spatial map(s) of key phenological metrics

breaks_dates <- as.Date(c("2020-01-01", "2021-01-01", "2022-01-01"))
breaks_numeric <- as.numeric(breaks_dates)  # Convert to numeric (days since 1970-01-01, by default)
labels_dates <- format(breaks_dates, "%Y-%m-%d")

p1 <- ggplot(data=blocks) +
  geom_sf(aes(fill=Maturity_1)) +
  scale_fill_continuous(low = "lightgreen", high = "darkgreen",
                        labels = function(x) format(as.Date(as.numeric(x), origin="1970-01-01"), "%B %d")) +
  geom_sf(data=srme,fill=NA,color="black",size=2.5) +
  labs(fill="Maturity") +
  guides(fill = guide_colourbar(barwidth = 0.5, barheight = 5.5, ticks=F,
                                 label.position = "right", title.position = "top",
                                 label.theme = element_text(angle = 0, size = 8))) +
  theme_void()

p2 <- ggplot(data=blocks) +
  geom_sf(aes(fill=Dormancy_1)) +
  scale_fill_continuous(low = "#ffffd4", high = "#993404",
                        labels = function(x) format(as.Date(as.numeric(x), origin="1970-01-01"), "%B %d")) +
  geom_sf(data=srme,fill=NA,color="black",size=2.5) +
  labs(fill="Dormancy") +
  guides(fill = guide_colourbar(barwidth = 0.5, barheight = 5.5, ticks=F,
                                 label.position = "right", title.position = "top",
                                 label.theme = element_text(angle = 0, size = 8))) +
  theme_void()

ggarrange(p1,p2)

# # Add a statistics column for legend (could do this for F1 too ...)
# blocks.m <- reshape2::melt(
#   blocks, id.vars = c("id","elevation_mn"), 
#   measure.vars = c("Greenup_1","MidGreenup_1","Maturity_1","Peak_1",
#                    "MidGreendown_1","Senescence_1","Dormancy_1"), variable.name = "metric"
# )

# Add a statistics column for legend (could do this for F1 too ...)
blocks.m <- reshape2::melt(
  blocks, id.vars = c("id","elevation_mn"), 
  measure.vars = c("Greenup_1","Maturity_1","Peak_1","Dormancy_1"), variable.name = "metric"
) %>%
  mutate(metric = as.character(metric),
         metric = as.factor(recode(metric,
                         "Greenup_1" = "Greenup",
                         "Maturity_1" = "Maturity",
                         "Peak_1" = "Peak Greenness",
                         "Dormancy_1" = "Dormancy")))
  
blocks.m$metric <- factor(blocks.m$metric, levels=c('Greenup', 'Maturity', 'Peak Greenness', 'Dormancy'))

head(blocks.m)

# Dot plot of phenology metric by elevation for all blocks

(p5 <- ggplot(data=blocks.m, aes(x=value,y=elevation_mn)) +
  geom_smooth(method="lm",colour="gray40", fill="gray70", size=0.8) +
  geom_point(size=1.2) +
  facet_wrap(~metric, scales="free_x") +
  theme_light(12) +
    labs(x="Date",y="Elevation"))

(p6 <- ggplot(data=blocks.m, aes(x=value,y=elevation_mn,color=metric)) +
  geom_point(size=1.2) +
  theme_light(12))

```


ROC, F1, MCC:

```{r}

accmeas <- read_csv('../../data/tabular/mod/results/accmeas_prop.csv')

# Calculate the averages for each cutoff value across model runs

accmeas.mn <- accmeas %>%
  mutate(cutoff = as.character(cutoff)) %>%
  group_by(cutoff) %>%
  summarise(
    prMn = mean(prSize,na.rm=T), # size of presence data (mean)
    prSd = sd(prSize,na.rm=T), # size of presence data (sd)
    bgMn = mean(bgSize,na.rm=T), # size of background data (mean)
    bgSd = sd(bgSize,na.rm=T), # size of background data (sd)
    fprMn = mean(fpr,na.rm=T), # False Positive Rate (mean)
    fprSd = sd(fpr,na.rm=T),
    tprMn = mean(tpr,na.rm=T), # True Positive Rate (mean)
    tprSd = sd(tpr,na.rm=T),
    precision = mean(precision,na.rm=T), # precision (mean)
    precisionSd = sd(precision,na.rm=T), 
    recall = mean(recall,na.rm=T), # recall (mean)
    recallSd = sd(recall,na.rm=T),
    f1 = mean(f1,na.rm=T), # F1 score (mean)
    f1Sd = sd(f1,na.rm=T),
    gmean = mean(gmean,na.rm=T), # Geometric Mean (mean)
    gmeanSd = sd(gmean,na.rm=T),
    mcc = mean(mcc,na.rm=T), # Matthew's Correlation Coefficient (mean)
    mccSd = sd(mcc,na.rm=T),
    accuracy = mean(accuracy,na.rm=T), # Overall accuracy (mean)
    accuracySd = sd(accuracy,na.rm=T)
  ) %>%
  ungroup() %>%
  mutate(cutoff = round(as.double(cutoff),3))

# Calculate optimum threshold based on F1 statistic

cutoffOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$cutoff
precisionOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$precision
recallOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$recall
fprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$fprMn
tprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$tprMn
max_f1 <- max(accmeas.mn$f1, na.rm = TRUE)

```


```{r warning=F, message=F}

# ROC Curve and label the AUC value (approximation)

# Get the AUC approx

# Ensure data is sorted by FPR
accmeas_mn_sorted <- accmeas.mn[order(accmeas.mn$fprMn), ]
# Compute AUC using trapz function in 'pracma'
auc_avg_approx <- trapz(accmeas_mn_sorted$fprMn, accmeas_mn_sorted$tprMn)

fs2a <- ggplot(data=accmeas) +
  geom_line(aes(x=fpr,y=tpr,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  geom_line(data=accmeas.mn, aes(x = fprMn, y = tprMn), color = "black", size = 0.8) +  # ROC curve average
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='False Positive Rate', y='True Positive Rate', tag="A") +
  geom_point(aes(x = fprOptMn, y = tprOptMn),
             color = "red", size = 3, shape = 19) +  # optimal threshold point
  geom_text(aes(x=fprOptMn, y=tprOptMn),
            label = paste0('Optimal threshold: ', round(cutoffOptMn,3),'\nApprox. AUC: ', round(auc_avg_approx,3)),
            nudge_x = 0.38, nudge_y = -0.08, size = 3.5) +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +  # diagonal
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

fs2b <- ggplot(data=accmeas) +
  geom_line(aes(x=cutoff,y=f1,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  geom_line(data=accmeas.mn, aes(x=cutoff, y = f1), color = "black", size = 0.8) +  # ROC curve average
  # geom_vline(xintercept=0.424, linetype="dashed", color="black") +
  geom_point(aes(x=cutoffOptMn, y=max_f1),
             color = "red", size = 3, shape = 19) +
  geom_text(aes(x=cutoffOptMn, y=max_f1),
            label = paste0('Optimal threshold: ', round(cutoffOptMn,3)),
            nudge_x = 0.0, nudge_y = 0.08, size = 3.5) +
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='Threshold', y='F1 Score', tag="B") +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

(fs2 <- ggarrange(fs2a,fs2b))

ggsave(fs2, file="../../figures/FigureS2_AUC_F1Max.png", dpi=300)

rm(fs2,fs2a,fs2b,accmeas_mn_sorted,auc_avg_approx)

```

Table S1: Performance metrics for the optimum cutoff value

Create a pretty table.

```{r}

library(flextable, quietly = T)

# Get the best F1 score for each model run
accmeas.best <- accmeas %>% 
  mutate(model = as.factor(model)) %>%
  group_by(model) %>% 
  top_n(1,f1) %>%
  ungroup() %>%
  mutate(model_iter = row_number()) %>%
  select(model,prSize,bgSize,tpr,precision,recall,f1,cutoff)

head(accmeas.best,10)

# Fix names and add units
names(accmeas.best) <- c("Model Seed",
                         "# of Presence",
                         "# of Background",
                         "True Positive Rate",
                         "Precision",
                         "Recall",
                         "F1-Score",
                         "Threshold")

# Set font name for table
fontname <- "Times New Roman"

# Create the flextable
(ft1 <- flextable(accmeas.best) %>%
 font(fontname = fontname, part = "all") %>%
 autofit() %>% fit_to_width(6.5))
print(ft1, preview = "docx")

# Write to a CSV
write_csv(accmeas.best, "../../figures/TableS1_Accuracy_MaxF1.csv")

```

Clean up!

```{r}

```
