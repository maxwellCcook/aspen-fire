---
title: "Figures"
output: html_notebook
root.dir: '~/Library/CloudStorage/OneDrive-Personal/mcook/aspen-fire'
---

```{r include=F}
source('setup.R')
```

# Study Region

```{r}
ggplot() +
  geom_sf(data=srme) +
  geom_sf(data=wrnf, fill="darkgrey") +
  geom_sf(data=blocks, fill=NA, lwd=0.4) +
  coord_sf(crs="EPSG:32613") +
  theme_light(11)
```

# Spectral Response 

Load the Sentinel-2 annual time-series (2019). 

```{r}

# Spectral Response
ts <- read_csv('../../data/tabular/mod/results/s2msi_l2a_aspen_TSy2019.csv', 
               show_col_types = FALSE) %>% 
  select(-c(id,.geo,TCB,TCG,TCW)) %>%
  rename(NDVI705 = NDRE)

head(ts)

```

Tidy the time-series data.

1. Remove cloud-contaminated pixels,
2. Pivot the table to gather bands,
3. Generate mean/median/stdev of reflectance by image date,
4. Calculate weekly summaries

```{r}

# Filter out cloud-contaminated pixels based on the Cloud Score + values
# Reference:  https://medium.com/google-earth/all-clear-with-cloud-score-bd6ee2e2235e

tsp <- ts %>%
  filter(
    cs >= 0.8, # >= Cloud Score + contamination
  ) %>%
  # add the month as a column
  mutate(month = month(image_date, label=TRUE, abbr=TRUE)) %>%
  # Filter null values
  filter(complete.cases(.))

# Test using some visualizations

# NDVI705 scatter plot with trend line
tsp %>%
  group_by(image_date) %>%
  summarize(band = median(NDVI705)) %>%
  ggplot(aes(x=image_date,y=band)) +
  geom_point(size=0.8) +
  geom_smooth(method="loess") +
  labs(x="Image Date", y="NDRE") +
  theme_bw(11)

# NDVI705 box plot
ggplot(data=tsp, aes(x=NDVI705, y=month)) +
  geom_boxplot() +
  coord_flip() +
  labs(y="Image Date", x="NDRE") +
  theme_bw(11)

rm(ts)

```

Now pivot the table longer:

```{r}

# Create a longer data frame
tsp_ <- tsp %>%
  select(c(starts_with("B"),image_date,
           SLAVI,NDVI705,NDMI,ChlRE,IRECI,MCARI)) %>%
  group_by(image_date) %>%
  summarize_all(list(median)) %>%
  pivot_longer(
    cols = -c(image_date),
    names_to="band",
    values_to="reflectance"
  ) %>%
  # add a month and week label
  mutate(
    month = month(image_date, label=TRUE, abbr=TRUE),
    week = isoweek(image_date),
    biweek = cut.Date(image_date, breaks="2 week", labels=FALSE)
  )

head(tsp_, n=19)

rm(tsp)
gc()

```

Breakpoint analysis to identify significant shift in spectral signature throughout the year based on NDRE:

```{r}

# Isolate one of the vegetation indices (Normalized Difference Red-edge Index)
df <- tsp_ %>% 
  filter(band == "NDVI705") %>% 
  select(image_date,week,reflectance) %>%
  group_by(image_date,week) %>%
  summarize(reflectance = median(reflectance)) %>%
  ungroup()

# Create a weekly time-series object
df.ts <- ts(df$reflectance, frequency = 52)

# Implement the changepoint analysis based on NDRE
result <- changepoint::cpt.meanvar(df.ts, method="PELT")
bp.ind <- changepoint::cpts(result)

# Map breakpoints to dates
print("Breakpoint weeks:")
bp.dates <- df$week[bp.ind]
bp.dates

# Plot the result
plot(result)

rm(df, df.ts, result, bp.ind, bp.dates)

```

Perform the analysis by spatial block grid to get an idea of the variation in time-series breakpoints.

Plot of median daily observations:

```{r fig.height=5, fig.width=9}

# Reorder band factors
tsp_$band <- factor(tsp_$band, 
                   levels = c("B2","B3","B4","B5","B6","B7","B8","B8A","B11","B12",
                              "ChlRE","IRECI","NDMI","NDVI705","SLAVI","MCARI"))

tsp_ %>%
  filter(str_detect(band,"B")) %>%
  ggplot(aes(x=image_date,y=reflectance ,color=factor(band))) +
  geom_line(linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  labs(x="Acquisition Date",y="Reflectance",color="S2 MSI Band") +
  theme_bw(14) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.text = element_text(size=10),
        legend.title = element_text(size=11))
```

## Figure 3: Spectral Response of Aspen Forest Presence Data

Gather the seasonal composite start and end dates:

```{r}
# Summer
(start_summer <- week(as.Date("2019-05-25")))
(end_summer <- week(as.Date("2019-08-13")))
# Autumn
(start_autumn <- week(as.Date("2019-09-02")))
(end_autumn <- week(as.Date("2019-11-14")))
```

Generate the weekly median reflectance.

```{r warning=F, message=F, fig.height=5, fig.width=9}

# List for band colors

band_colors <- c(
  "B2"  = "#1E90FF",  # Blue: Dodger Blue
  "B3"  = "#00FF7F",  # Green: Spring Green
  "B4"  = "#FF0000",  # Red: Pure Red
  "B5"  = "#FFA07A",  # Red Edge: Light Salmon
  "B6"  = "#FF8C00",  # NIR: Dark Orange
  "B7"  = "#D2691E",  # NIR: Chocolate
  "B8"  = "#FFD700",  # NIR: Gold
  "B8A" = "#B8860B",  # NIR: Dark Goldenrod
  "B11" = "#008B8B",  # SWIR: Dark Cyan (dark shade of teal)
  "B12" = "#800080"   # SWIR: Purple
)


# Group by week, calculate the mean, plot

f3a <- tsp_ %>%
  filter(str_detect(band,"B")) %>%
  group_by(band,week) %>%
  summarize(refl = mean(reflectance)) %>%
  ggplot(aes(x=week,y=refl,color=factor(band))) +
  geom_line(linewidth=0.6) +
  scale_color_manual(values = band_colors) +
  labs(x="Acquisition Week",y="Reflectance",color=NULL) +
  theme_bw(11) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.text = element_text(size=8),
        legend.title = element_text(size=8),
        legend.position = c(0.2,0.95),
        legend.direction = "horizontal",
        legend.background = element_rect(fill="white", color="black"),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial")) +
  annotate('rect', xmin=start_summer, xmax=end_summer, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  annotate('rect', xmin=start_autumn, xmax=end_autumn, ymin=0, ymax=6000, alpha=.3, fill='gray') +
  geom_vline(xintercept=start_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=start_autumn, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_autumn, linetype="dotted", lwd=0.8)

f3a
```

## Figure 1B: Time-series charts of the spectral indices:

```{r message=F, warning=F}

# All bands

# Calculate the maximum reflectance for each band
max_refl_band <- tsp_ %>%
  group_by(band) %>%
  summarize(max_refl = max(reflectance))

# Now create your plot
tsp_ %>%
  group_by(band, week) %>%
  summarize(refl = mean(reflectance), .groups = 'drop') %>%
  ggplot(aes(x = week, y = refl, group = 1)) +
  geom_line() +
  geom_rect(data = max_refl_band, aes(xmin=start_summer, xmax=end_summer, ymin=0, ymax=max_refl), alpha=.3, fill='gray',
            inherit.aes = FALSE) +
  geom_rect(data = max_refl_band, aes(xmin=start_autumn, xmax=end_autumn, ymin=0, ymax=max_refl), alpha=.3, fill='gray',
            inherit.aes = FALSE) +
  geom_vline(xintercept = start_summer, linetype = "dotted", lwd = 0.8) +
  geom_vline(xintercept = end_summer, linetype = "dotted", lwd = 0.8) +
  geom_vline(xintercept = start_autumn, linetype = "dotted", lwd = 0.8) +
  geom_vline(xintercept = end_autumn, linetype = "dotted", lwd = 0.8) +
  facet_wrap(. ~ band, scales = "free_y") +
  theme_minimal() +
  theme(axis.title.y = element_text(size = 8, face = "italic",
                                    margin = unit(c(0, 0.4, 0, 0), "cm")),
        axis.title.x = element_text(size = 8, face = "italic",
                                    margin = unit(c(0.4, 0, 0, 0), "cm")),
        axis.text = element_text(size = 7),
        strip.text.x = element_text(size = 8))

# Spectral indices

max_refl_band_vi <- max_refl_band %>%
  filter(!str_detect(band,"B"))

f3b <- tsp_ %>%
  filter(!str_detect(band,"B")) %>%
  group_by(band,week) %>%
  summarize(refl = mean(reflectance)) %>%
  ggplot(aes(x=week, y=refl, group=1)) +
  geom_line(linewidth=0.6) +
  labs(x="Acquisition Week",y="") +
  geom_rect(data = max_refl_band_vi, aes(xmin = start_summer, xmax = end_summer, ymin = 0, ymax = max_refl), alpha = .3, fill = 'gray',
            inherit.aes = FALSE) +
  geom_rect(data = max_refl_band_vi, aes(xmin = start_autumn, xmax = end_autumn, ymin = 0, ymax = max_refl), alpha = .3, fill = 'gray',
            inherit.aes = FALSE) +
  geom_vline(xintercept=start_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_summer, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=start_autumn, linetype="dotted", lwd=0.8) +
  geom_vline(xintercept=end_autumn, linetype="dotted", lwd=0.8) +
  facet_wrap(. ~ band, scales = "free") +
  theme_light(11) +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3b

rm(max_refl_band,max_refl_band_vi)

```

## Figure 3C: Boxplot of seasonal composites:

```{r}

cols <- c(
  "Summer" = "#87CEEB", 
  "Autumn" = "#DAA520"
)

seasonal <- tsp_ %>%
  mutate(season = if_else(week>=22&week<=37,"Summer","na"),
         season = if_else(week>=37&week<=48,"Autumn",season)) %>%
  filter(season!="na")

seasonal$season <- factor(seasonal$season, levels = c("Summer","Autumn"))
  
f3c <- seasonal %>%
  filter(str_detect(band,"B")) %>%
  ggplot(aes(x=band,y=reflectance,fill=season)) +
  geom_boxplot(outlier.size = 0.5, outlier.color = "grey30") +
  scale_fill_manual(values = cols) +
  theme_bw(12) +
  labs(x="Sentinel-2 MSI Band",y="Reflectance",fill="Season: ") +
  theme(axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        legend.position = "none",
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3c

```

## Figure 1D: Seasonal differences in the spectral indices

```{r}

f3d <- seasonal %>%
  filter(!str_detect(band,"B")) %>%
  ggplot(aes(y=reflectance)) +
  geom_boxplot(aes(fill=season)) +
  scale_fill_manual(values = cols) +
  facet_wrap(. ~ band, scales = "free") +
  theme_bw(12) +
  labs(fill="Season",y="") +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        # legend.position = c(0.85,0.2),
        legend.position = "bottom",
        legend.title = element_text(size=12),
        legend.text = element_text(size=12),
        legend.spacing.y = unit(1.5, "cm"),
        legend.spacing.x = unit(0.5, 'cm'),
        plot.margin = unit(c(1.2,0.5,1.2,0.5), 'lines'),
        text = element_text(family = "Arial"))
f3d

```

Combine the plots:

```{r fig.width=7.5, fig.height=10, message=F, warning=F}

# Arrange in a multi-panel plot

f3 <- ggarrange(f3a,f3b,f3c,f3d, nrow=2,ncol=2, widths=c(1, 0.75), labels = c("A", "B", "C", "D"))
f3

# Save it out

ggsave(f3, file = "../../figures/Figure3_SpectralResponse.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Version 2:

```{r fig.width=14, fig.height=8}

f3_ <- ggarrange(f3a,ggarrange(f3c,f3d,nrow=1,ncol=2),
                  ncol=1,widths=c(1, 0.75),
                  labels = c("A", "B", "C"))
f3_

ggsave(f3_, file = "../../figures/Figure3_SpectralResponse_v2.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

Clean up the time-series / spectral response data:

```{r}
rm(f3,f3a,f3b,f3c,f3d,seasonal,band_colors,cols,end_autumn,end_summer,start_autumn,start_summer,tsp_)
gc()
```

# Model Selection and Accuracy Assessment

Load the accuracy assessment results for the best performing model (the final model in GEE). This represents the most parsimonious model (multicollinear bands removed and feature selection in rfUtilities). See the "accmeas.R" script.

```{r}
accmeas <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_accmeas.csv',
                    show_col_types = FALSE)
opt_thresh <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_opt_thresh.csv',
                    show_col_types = FALSE)

glimpse(accmeas)
head(opt_thresh)

```

## Figure 3: Classification Scenarios

```{r fig.width=6.5, fig.height=3.5, message=F, warning=F}

scenarios <- read_csv("../../data/tabular/mod/results/scenarios/rf_accmets_scenarios.csv", show_col_types = FALSE)

# Read in the best performing model results to append
final_model <- opt_thresh %>%
  mutate(Feature_Set = "Final_Model") %>%
  rename(F1 = f1) %>%
  select(Feature_Set,F1)

scenarios <- bind_rows(scenarios,final_model)
head(scenarios)

# Box plot version
ggplot(data=scenarios, aes(x=reorder(Feature_Set,F1),y=F1)) +
  geom_boxplot(outlier.size=0.6, fill="lightblue") +
  ylim(0,1) +
  labs(x="Classification Scenario",y="F1-score", tag="A") +
  theme_bw(10) +
  theme(
        plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
        axis.title.y = element_text(size=10,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=10,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=9),
        strip.text.x = element_text(size = 10),
        axis.text.x = element_text(angle = 45, hjust=1),
        text = element_text(family = "Arial"))

# Calculating the means and standard errors for F1-scores
# Plot as a bar chart with standard errors
f3a <- scenarios %>%
  group_by(Feature_Set) %>%
  summarise(
    Mean = mean(F1),
    SE = sd(F1) / sqrt(n())
  ) %>%
  # Plotting the bar chart with error bars
  ggplot(aes(x=reorder(Feature_Set, Mean), y=Mean)) +
    geom_bar(stat="identity", fill="lightblue", width=0.75) +
    geom_errorbar(aes(ymin=Mean-SE, ymax=Mean+SE), width=0.2) +
    ylim(0, 1) +
    labs(x="Classification Scenario", y="F1-score") +
    theme_bw(base_size = 10) +
    theme(
      plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
      axis.title.y = element_text(size=10, face="italic", margin = unit(c(0,0.4,0,0), "cm")),
      axis.title.x = element_text(size=10, face="italic", margin = unit(c(0.4,0,0,0), "cm")),
      axis.text = element_text(size=9),
      strip.text.x = element_text(size = 10),
      axis.text.x = element_text(angle = 45, hjust=1),
      text = element_text(family = "Arial")
    )
f3a

# Save out
ggsave(f3a, file = "../../figures/Figure4A_Class_Scenarios.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

## Table X. Average F1-score and other metrics for the classification scenarios and the final model

```{r}
# Read in the best performing model results to append
final_model <- opt_thresh %>%
  mutate(Feature_Set = "Final_Model") %>%
  rename(F1 = f1) %>%
  select(Feature_Set,F1)

# Add the final model to the data frame
scenarios_ <- bind_rows(scenarios,final_model)

# Create the final table
df <- scenarios_ %>%
  group_by(Feature_Set) %>%
  summarize(
    F1_mn = mean(F1),
    F1_sd = sd(F1)
  ) %>%
  mutate(
    n_features = if_else(Feature_Set == "Summer_S1" | Feature_Set == "Winter_S1", 5, 0),
    n_features = if_else(Feature_Set == "Summer_S1_GLCM" | Feature_Set == "Winter_S1_GLCM", 13, n_features),
    n_features = if_else(Feature_Set == "Summer_Winter_S1", 23, n_features),
    n_features = if_else(Feature_Set == "Summer_S2" | Feature_Set == "Autumn_S2", 13, n_features),
    n_features = if_else(Feature_Set == "Summer_S2_VI" | Feature_Set == "Autumn_S2_VI", 19, n_features),
    n_features = if_else(Feature_Set == "Summer_Autumn_S2", 35, n_features),
    n_features = if_else(Feature_Set == "Combined_S1_S2", 55, n_features),
    n_features = if_else(Feature_Set == "Final_Model", 17, n_features)
  )

# Create a tidy table

# Set font name for table
fontname <- "Times New Roman"

# Clean up extra rows and digits
cleaned <- df %>%
 mutate_if(is.double, ~ round(., digits = 4)) %>%
 # Sort from fastest to slowest
 arrange(desc(F1_mn))

# Fix names and add units
names(cleaned) <- c("Feature Set","Mean F1-score","Standard Deviation","Number of Features")

# Create the flextable
ft <- flextable::flextable(cleaned) %>%
  flextable::font(fontname = fontname, part = "all") %>%
  flextable::autofit() %>% 
  flextable::fit_to_width(7.5)
ft
# print(ft, preview = "docx")

rm(scenarios_,df,ft,fontname,cleaned)
```

## Figure S2. Model Performance Metrics; AUC-PR, Optimum Cutoff

This will go into the supplement.

The optimum cutoff value for classification is defined as the average cutoff across folds at which the F1-score is maximized. We can see the optimum cutoff value and how it corresponds with F1-score and the AUC-PR curve.

```{r warning=F, fig.width=6.5, fig.height=3}
paste0("Optimum cutoff for classification: ",round((opt_cutoff <- mean(opt_thresh$cutoff_f1)),3))
paste0("Average F1-score: ",round((f1max <- max(opt_thresh$f1)),3))

# AUC-PR Curve (approximation)

fs2a <- ggplot(data=accmeas) +
  geom_line(aes(x=fpr,y=tpr,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='False Positive Rate', y='True Positive Rate', tag="A") +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +  # diagonal
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

fs2b <- ggplot(data=accmeas) +
  geom_line(aes(x=cutoff,y=f1,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  # geom_vline(xintercept=0.50, linetype="dashed", color="black") +
  geom_point(aes(x=opt_cutoff, y=f1max),
             color = "black", size = 3, shape = 19) +
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='Classification Threshold', y='F1 Score', tag="B") +
  geom_text(aes(x=opt_cutoff, y=f1max),
            label = paste0('Optimal threshold: ', round(opt_cutoff,3)),
            nudge_x = 0.0, nudge_y = 0.05, size = 3.5) +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

# Arrange
(fs2 <- ggarrange(fs2a,fs2b))

# Save out
ggsave(fs2, file = "../../figures/FigureS2_Model_Performance.png",
       dpi = 300, bg="white") # adjust dpi accordingly

rm(fs2a,fs2b,fs2)

```

Using the optimum cutoff value, we can classify the test data and calculate the Precision, Recall, and F1-score. 

```{r}
testPart <- "../../data/tabular/mod/results/best_model/southern_rockies_test_probs_n55.csv"
# Assign the classification label based on the optimum cutoff
testData <- read_csv(testPart, show_col_types=FALSE) %>%
  rename(gee_id = `system:index`,
         TrueLabel = label) %>%
  dplyr::select(-.geo) %>%
  mutate(probability = probability*0.001, # scale back
         ClassLabel = if_else(probability >= opt_cutoff, 1, 0)) %>%
  group_by(seed) %>%
  summarize(
    tp = sum(TrueLabel == 1 & ClassLabel == 1),
    tn = sum(TrueLabel == 0 & ClassLabel == 0),
    fp = sum(TrueLabel == 0 & ClassLabel == 1),
    fn = sum(TrueLabel == 1 & ClassLabel == 0),
    accuracy = (tp + tn) / (tp + tn + fp + fn),
    precision = tp / (tp + fp),
    recall = tp / (tp + fn),
    f1 = 2 * (precision * recall) / (precision + recall),
    .groups = 'drop' # This ensures that the result is a single data frame, not a grouped one
  )
head(testData,10)

# First, get the overall F1/MCC for the classification
print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~")
paste0("Average F1-score for the best performing model at the optimum cutoff: ",mean(testData$f1))
paste0("Range of F1-scores: ",range(testData$f1))
paste0("StDev of F1-scores: ",sd(testData$f1))
summary(testData$f1)

# rm(testPart,testData)
```

Plot the model accuracy results for the optimum threshold.

Figure 4A: Model Accuracy (F1 and OA)

```{r message=F, warning=F, fig.height=3.5, fig.width=6.5}

cols <- c("F1 Score"="#1f78b4","Overall Accuracy"="gray75")

testData <- testData %>%
  mutate(Fold = as.numeric(factor(seed, levels = sort(unique(seed)))))

f4b <- ggplot(data=testData) +
  geom_hline(yintercept=mean(testData$precision),linetype="dashed",color="gray85") +
  geom_hline(yintercept=mean(testData$recall),linetype="dashed",color="gray45") +
  geom_hline(yintercept=mean(testData$f1),linetype="dashed",color="#1f78b4") +
  # Plot the Precision and Recall
  geom_line(aes(x=factor(Fold),y=precision,group=1),color="gray65") +
  geom_line(aes(x=factor(Fold),y=recall,group=1),color="gray35") +
  # Plot the F1-score
  geom_line(aes(x=factor(Fold),y=f1,group=1),color="#1f78b4") +
  geom_point(aes(x=factor(Fold),y=f1,size=f1), color="#1f78b4") +
  scale_size(range = c(3,6)) +
  coord_cartesian(ylim = c(0.85, 1)) +
  labs(x="Fold", y="Score", tag="B") +
  # annotate("text", x = 2.6, y = 0.88, label = paste("Average F1 Score: ", round(mean(testData$f1), 2))) +
  theme_bw() +
  guides(size="none") +
  theme(
        plot.margin = unit(c(0.2,0.2,0.2,0.2), 'lines'),
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11),
        text = element_text(family = "Arial"))
f4b

ggsave(f4b, file = "../../figures/Figure4A_Best_Model_Acc_F1.png",
       dpi = 300, bg="white") # adjust dpi accordingly

```

```{r fig.width=7.5, fig.height=7.5}
arr4 <- ggarrange(f4a,ggarrange(f4b,f5b, ncol=2, nrow=1, align='h'), nrow=2, align="h")
arr4
ggsave(arr4, file = "../../figures/Figure4_ModelSel_BestModel_ThreshOpt.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```

## Figure 6: Feature importance from the best model

```{r}
# Feature Importance
ftr_imp <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_feature_imps_n55.csv',
                    show_col_types = FALSE)
glimpse(ftr_imp)
```

```{r message=F, warning=F, fig.width= 6.5, fig.height=3.5}

# Tidy the data frame
df.imp <- ftr_imp %>% 
  select(-c(.geo,`system:index`)) %>%
  rename(model = seed) %>%
  mutate(model = as.factor(model))

# Pivot longer
df.imp.p <- df.imp %>%
  pivot_longer(cols = -model) %>%
  rename(importance = value,
         band = name) %>%
  mutate(season = if_else(str_detect(band,"_autumn"), "Autumn S2", "Summer S2"),
         season = if_else(str_detect(band,"_winter"), "Winter S1", season),
         season = if_else(str_detect(band,"VV_summer"), "Summer S1", season),
         season = if_else(str_detect(band,"VH_summer"), "Summer S1", season))
glimpse(df.imp.p)

# Grab the top 20 over all model runs
top <- df.imp.p %>%
  group_by(band) %>%
  summarize(median = median(importance)) %>%
  ungroup()
top <- head(arrange(top,desc(median)), n = 10)

# Color palette

cols <- c(
  "Summer S2" = "#87CEEB", 
  "Autumn S2" = "#DAA520",
  "Winter S1" = "gray29",
  "Summer S1" = "gray89"
)

# Boxplot

# %>% filter(band %in% top$band)
f6 <- ggplot(data=df.imp.p %>% filter(band %in% top$band), 
              aes(x=reorder(band,importance), fill=season)) +
  geom_boxplot(aes(y=importance), position = position_dodge(0.5)) +
  scale_fill_manual(values = cols, 
                    labels = c("Autumn S2","Summer S1","Summer S2","Winter S1")) +
  coord_flip() +
  theme_bw(11) +
  theme(axis.text.x = element_text(size=11),
        axis.text.y = element_text(angle = 0, vjust=0, size=11),
        axis.title = element_text(size=11,face="italic"),
        legend.position = "bottom",
        legend.justification = c(1.2,0.5), # Left-aligns the legends
        legend.text = element_text(size=11),
        text = element_text(family = "Arial"),
        plot.margin=unit(c(0.5,0.5,0.5,0.5),"cm")) +
  labs(x="Feature", y="Importance", fill="Season: ")
f6

ggsave(f6, file = "../../figures/Figure6_FeatureImportance_top10.png",
       dpi=300, bg="white") # adjust dpi accordingly

```

Clean up!

```{r}
rm(list = ls.str(mode = 'numeric'))
rm(accmeas,accmeas.best,accmeas.mn,accmeas.s,df.imp,
   df.imp.p,f4,f4a,f4b,f6,ftr_imp,top,cols,arr4,cleaned,
   df,f5b,final_model,ft,opt_thresh,scenarios,scenarios_,testData)
gc()
```

# Spatial Agreement and Landscape Patch Dynamics

## Table X: Accuracy of the reference datasets based on test data

```{r message=F}
ref_acc <- read_csv('../../data/tabular/mod/results/best_model/southern_rockies_ref_accmeas.csv',
                    show_col_types = F)
head(ref_acc)

# Create a tidy table
df <- ref_acc %>%
  filter(metric == "Predicted") %>%
  select(reference,precision, recall, f1_score)
head(df)

# Create a tidy table

# Set font name for table
fontname <- "Times New Roman"

# Clean up extra rows and digits
cleaned <- df %>%
 mutate_if(is.double, ~ round(., digits = 4)) %>%
 # Sort from fastest to slowest
 arrange(desc(f1_score))

# Fix names and add units
names(cleaned) <- c("Data Source","Precision","Recall","F1-score")

# Create the flextable
ft <- flextable::flextable(cleaned) %>%
  flextable::font(fontname = fontname, part = "all") %>%
  flextable::autofit() %>% 
  flextable::fit_to_width(7.5)
ft
print(ft, preview = "docx")

rm(df,ref_acc)
```

## Figure 7: Spatial Agreement (pixel-based)

```{r}
aggr.sr <- aggr.sr %>%
  mutate(source = if_else(source == "usfs_treemap16_balive_int_bin_srme_10m", "USFS TreeMap", source))
glimpse(aggr.sr)
```

Remove blocks with little to no aspen forest cover. First look at the distribution of aspen forest cover across spatial blocks.

```{r warning=F, message=F}

# Plot the distribution of aspen area
blocks %>%
  st_set_geometry(NULL) %>%
  as_tibble() %>%
  mutate(s2aspen_sum = as.integer(s2aspen_sum)) %>%
  ggplot(aes(x=s2aspen_sum)) +
  scale_x_continuous(trans="log") +
  geom_histogram() +
  theme_minimal(12)

# Filter out non-aspen blocks
blocks_aspen <- blocks %>%
  filter(s2aspen_sum > 100000)

```

```{r message=F, fig.width = 6.5, fig.height = 3.25}

flabs <- c(precision = "Precision", recall = "Recall", f1 = "F1-score")

# Reshape the agreement table for plotting facet wrap

# Southern Rockies (by block)
aggr.sr.m <- reshape2::melt(
  aggr.sr, id.vars = c("blocksize", "source", "region", "block"), 
  measure.vars = c("precision", "recall", "f1"), variable.name = "statistic"
) %>%
  na.omit() %>%
  filter(blocksize == 1,
         block %in% blocks_aspen$id)

# White River NF
aggr.wr.m <- reshape2::melt(
  aggr.wr, id.vars = c("blocksize", "source", "region"), 
  measure.vars = c("precision", "recall", "f1"), variable.name = "statistic"
) %>%
  na.omit() %>%
  filter(blocksize == 1)

# Facet wrap plot of the statistics by block group

f7 <- ggplot(data=aggr.sr.m, aes(x=factor(blocksize), y=value, fill=factor(source))) +
  geom_boxplot(position = position_dodge()) + 
  scale_fill_viridis_d(labels=c("LANDFIRE EVT","USFS TreeMap","USFS ITSP"), name="",
                       breaks=c("LANDFIRE EVT", "USFS TreeMap", "USFS ITSP")) +
  facet_wrap(~statistic, labeller = labeller(statistic = flabs)) +
  theme_bw(11) +
  theme(legend.position = "bottom",
        legend.box = "vertical",
        legend.justification = c(0.5,0.5), # Left-aligns the legends
        legend.spacing.y = unit(-5, "pt"), # Adjusts the gap between the legends
        # legend.text = ggtext::element_markdown(halign = 0), # This aligns each individual legend's text to the left
        axis.title.x=element_blank(),  # Remove x axis title
        axis.text.x=element_blank(),   # Remove x axis text
        axis.ticks.x=element_blank(),  # Remove x axis ticks
        axis.title = element_text(size=11,face="italic")) +
        # text = element_text(family = "Times New Roman")) +
  labs(x="Blocksize", y="Value")

# Add the WRNF statistics
f7 <- f7 +
  geom_point(data=aggr.wr.m, aes(x=factor(blocksize), y=value, group=factor(source)),
             position=position_dodge(0.75), shape=18, size=4, color="white") +
  # Then add the actual point in black
  geom_point(data=aggr.wr.m, aes(x=factor(blocksize), y=value, group=factor(source)),
             position=position_dodge(0.75), shape=18, size=3, color="black") +
  scale_shape_manual(name="Subregion", values=c("White River NF" = 8)) +
  guides(
    fill=guide_legend(override.aes=list(shape=NA)), # No shape in the fill legend
    shape=guide_legend(title=" ", override.aes=list(color="black")) # Shape legend for Subregion
  )
f7

# Save out
ggsave(f7, file = "../../figures/Figure7_Agreement_Box.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```
```{r}
# Add a spatial map of statistics by blocks
blocks_ <- blocks %>%
  mutate(id = as.numeric(id)-1) %>%
  rename(block = id) %>%
  left_join(aggr.sr, by="block") %>%
  pivot_longer(cols = c(precision, recall, f1), names_to = "statistic", values_to = "value") %>%
  na.omit()

f7b <- ggplot(data = blocks_) +
  geom_sf(aes(fill = value)) +
  geom_sf(data=srme, fill=NA, color="grey20", linewidth=0.4) +
  facet_grid(source ~ statistic) +
  scale_fill_viridis_c(option = "C") + # Use a continuous color scale
  theme_void() +
  theme(
    strip.text.x = element_text(size = 10),
    legend.position = "bottom"
  ) +
  guides(fill = guide_colourbar(direction = "horizontal", barwidth = 10, barheight = 0.60,
                                ticks=F, title.position = "left"),
         label.theme = element_text(angle = 0, size = 9)) +
  labs(fill="", tag="B")
f7b

# Save out
ggsave(f7b, file = "../../figures/Figure7_Agreement_Maps.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```

Join the two plots.

```{r}

f7 <- f7 + theme(plot.margin = unit(c(0.5, 10, 0.5, 0.5),"mm")) # Add right margin to the left plot
f7b <- f7b + theme(plot.margin = unit(c(0.5, 0.5, 10, 0.5),"mm")) # Add left margin to the right plot

arr7 <- ggarrange(f7, f7b, ncol=2, align="h", widths = c(1.5,1))
arr7

# Save out
ggsave(arr7, file = "../../figures/Figure7_Agreement_Box_Maps_Arr.png",
       dpi = 300, bg="white") # adjust dpi accordingly
```


```{r}

brewer.pal(n=5,"Set1")

cols <- c("#4DAF4A", "#984EA3", "#FF7F00")

glimpse(ref.global)

# # Get an average f1 score table
# f1mn <- ref.global %>%
#   group_by

# Add a statistics column for legend (could do this for F1 too ...)
ref.global.m <- reshape2::melt(
  ref.global, id.vars = c("blocksize", "source", "region"), 
  measure.vars = c("prec", "rec"), variable.name = "statistic"
)

glimpse(ref.global.m)

f7a <- ggplot(data=ref.global.m) +
  geom_line(aes(x=blocksize,y=value,color=factor(source), linetype=statistic), linewidth=0.6) +
  geom_point(data=ref.global, aes(x=blocksize, y=f1, color=source)) +
  scale_x_continuous(breaks=c(1,3,5,7,9)) +
  scale_linetype_manual(values = c("prec" = "dotted", "rec" = "solid"), name="Statistic: ",
                        labels=c("Precision","Recall")) +
  facet_wrap(~region, scales = "fixed") +
  scale_color_manual(values=cols, labels=c("LANDFIRE EVT","USFS TreeMap","USFS ITSP"), name="Source: ") +
  theme_light(14) +
  ylim(0,1) +
  theme(legend.position = "top",
        legend.box = "vertical",
        legend.justification = c(0.5,0.5), # Left-aligns the legends
        legend.spacing.y = unit(-10, "pt"), # Adjusts the gap between the legends
        legend.text = ggtext::element_markdown(halign = 0), # This aligns each individual legend's text to the left
        axis.title = element_text(size=12,face="italic"),
        text = element_text(family = "Arial")) +
  labs(x="Blocksize (pixels)",y="Value")
  
f7a

ggsave(f7a, file = "../../figures/Figure7_Global_PrecRec_Agreement.png", dpi=300)

```

Clean up! 

```{r}
rm(ref.global,ref.global.m,f7a,f7b,f7,ref.focal)
gc()
```

## Figure 8: Landscape Patch Dynamics

```{r}
class.sr_ <- class.sr %>%
  mutate(source = if_else(source=="lc16_evt_200_bin_srme_10m", "LANDFIRE EVT", source),
         source = if_else(source=="s2aspen_prob_10m_binOpt_srme", "Sentinel-based Map", source),
         source = if_else(source=="usfs_itsp_aspen_ba_gt10_srme_10m", "USFS ITSP", source),
         source = if_else(source=="usfs_treemap16_balive_int_bin_srme_10m", "USFS TreeMap", source))
patch.sr_ <- patch.sr %>%
  mutate(source = if_else(source=="lc16_evt_200_bin_srme_10m", "LANDFIRE EVT", source),
         source = if_else(source=="s2aspen_prob_10m_binOpt_srme", "Sentinel-based Map", source),
         source = if_else(source=="usfs_itsp_aspen_ba_gt10_srme_10m", "USFS ITSP", source),
         source = if_else(source=="usfs_treemap16_balive_int_bin_srme_10m", "USFS TreeMap", source),
         area_qt = factor(ntile(area, 4), labels = c("Q1", "Q2", "Q3", "Q4")))
glimpse(patch.sr_)
glimpse(class.sr_)

class.wr_ <- class.wr %>%
  mutate(region = "wrnf") %>%
  mutate(source = if_else(source=="lc16_evt_200_bin_wrnf_10m", "LANDFIRE EVT", source),
         source = if_else(source=="s2aspen_prob_10m_binOpt_wrnf", "Sentinel-based Map", source),
         source = if_else(source=="usfs_itsp_aspen_ba_gt10_wrnf_10m", "USFS ITSP", source),
         source = if_else(source=="usfs_treemap16_balive_int_bin_wrnf_10m", "USFS TreeMap", source))
patch.wr_ <- patch.wr %>%
  mutate(region = "wrnf") %>%
  mutate(source = if_else(source=="lc16_evt_200_bin_wrnf_10m", "LANDFIRE EVT", source),
         source = if_else(source=="s2aspen_prob_10m_binOpt_wrnf", "Sentinel-based Map", source),
         source = if_else(source=="usfs_itsp_aspen_ba_gt10_wrnf_10m", "USFS ITSP", source),
         source = if_else(source=="usfs_treemap16_balive_int_bin_wrnf_10m", "USFS TreeMap", source),
         area_qt = factor(ntile(area, 4), labels = c("Q1", "Q2", "Q3", "Q4")))
rm(patch.sr,class.sr,patch.wr,class.wr)
```

Get some summary statistics:

```{r}
class.sr_ %>%
  group_by(source) %>%
  summarize(
    total_area_km2 = sum(total_area) * 0.01
  ) %>%
  ggplot(aes(x=reorder(source, total_area_km2), y=total_area_km2)) +
  geom_bar(stat="identity", fill="light green") +
  theme_light(12)
```

## Table X: Class-level statistics

```{r}
df1 <- class.sr_ %>%
  group_by(source) %>%
  summarize(
    total_area_km2 = sum(total_area) * 0.01,
    n_patch_total = sum(n_patch),
    patch_density_mn = mean(patch_den)
  )

df2 <- patch.sr_ %>%
  group_by(source) %>%
  summarize(
    patch_size_mn = mean(area),
    per_ar_r_mn = mean(perimeter_area_ratio)
  )

df <- left_join(df1,df2,by="source")
head(df)

rm(df1,df2)

# Make a tidy table
# Set font name for table
fontname <- "Times New Roman"
# Clean up extra rows and digits
cleaned <- df %>%
 mutate_if(is.double, ~ round(., digits = 2)) %>%
 # Sort from fastest to slowest
 arrange(total_area_km2)
# Fix names and add units
names(cleaned) <- c("Data Source","Total Area (Km2)","Number of Patches","Patch Density",
                    "Average Patch Size (ha)","Average Perimeter/Area Ratio")
# Create the flextable
ft <- flextable::flextable(cleaned) %>%
  flextable::font(fontname = fontname, part = "all") %>%
  flextable::autofit() %>% 
  flextable::fit_to_width(7.5)
ft
print(ft, preview = "docx")

```

Plot the total area box plot across spatial blocks for the Southern Rockies:

```{r fig.width=6.5, fig.height=3.5}

# Combine the White River NF and SRME to plot patch statistics
df <- bind_rows(patch.sr_,patch.wr_)
# Plot facet wrap of patch size
df <- df %>%
  group_by(source,region) %>%
  summarize(
    patch_size = mean(area),
    per_ar_r = mean(perimeter_area_ratio)
  ) 
glimpse(df)

# Get the class metrics in the same format
df2 <- bind_rows(class.sr_,class.wr_) %>%
  group_by(source,region) %>%
  summarize(
    patch_den = mean(patch_den)
  )

df_ <- left_join(df,df2,by=c("region","source"))

# Pivot longer

metric_labels <- c(patch_size = "Patch Size (ha)",
                   per_ar_r = "Perimeter-Area Ratio",
                   patch_den = "Patch Density")

df.long <- df_ %>%
  pivot_longer(cols = c(contains("_")),
               names_to = "metric",
               values_to = "value") %>%
  mutate(region = if_else(region=="srme","Southern Rockies","White River NF"),
         source = if_else(source=="Sentinel-based Map","Sentinel-based",source),
         source = factor(source, levels = rev(levels(reorder(source, value)))))

df.long$source <- factor(df.long$source,levels=c('Sentinel-based', 'LANDFIRE EVT', 'USFS TreeMap', 'USFS ITSP'))

cols <- c("#005a32","#a1d99b")

# Grouped bar chart
f7 <- ggplot(data=df.long, aes(x=source, y=value, fill=factor(region))) +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_fill_manual(values=cols) +
  facet_wrap(~metric, scales = "free_y", labeller = labeller(metric = metric_labels)) + # Faceting by summary variable
  labs(x="", y="Value", fill="Region") + # Adding labels
  theme_bw(10) +
  theme(legend.position = "top") +
  theme(axis.text.x = element_text(angle=45, hjust=1)) # Improving readability of x-axis labels
f7

ggsave(f7, file = "../../figures/Figure7_Landscape_Summaries.png", dpi=300)


```

Calculate some grouped statistics (to compare with the class metrics results)

```{r message=F, warning=F, fig.height=8, fig.width=8}

# Also create a grouped summary
(patch.summary <- patch_metrics %>%
  group_by(source,region) %>%
  summarize(area_md = median(area), # convert to hectares
            area_mn = mean(area),
            area_sum = sum(area),
            perim_md = median(perimeter),
            perim_mn = mean(perimeter),
            par_md = median(perimeter_area_ratio),
            par_mn = mean(perimeter_area_ratio),
            si_md = median(shape_index),
            si_mn = mean(shape_index)) %>%
  ungroup())

(patch.long <- patch.summary %>%
  pivot_longer(cols = c(contains("_")),
               names_to = "metric",
               values_to = "value"))

patch.long$source <- factor(patch.long$source,levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))

(ggplot(data = patch.long, aes(x=source, y=value, fill=region)) +
    geom_bar(stat="identity", position="dodge", width=0.7) +
    facet_wrap(~metric, scales="free") + 
    theme_minimal(14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
    text = element_text(family = "Arial")))

(f8s <- ggplot(data = patch.long, aes(x=source, y=value, fill=region)) +
    geom_bar(stat="identity", position="dodge", width=0.7) + 
    theme_minimal(14) +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
    text = element_text(family = "Arial")))

```

Grab some summary statistics on the patch dynamics:

```{r}

a <- patch.long %>% filter(region=="SRME",metric=="area_mn",source=="Aspen10m")
b <- patch.long %>% filter(region=="SRME",metric=="area_mn",source=="LFEVT")

print("Difference in mean patch size for the SRME: ")
((b$value-a$value)/b$value)*100

a <- patch.long %>% filter(region=="WRNF",metric=="area_mn",source=="Aspen10m")
b <- patch.long %>% filter(region=="WRNF",metric=="area_mn",source=="LFEVT")

print("Difference in mean patch size for the WRNF: ")
((b$value-a$value)/b$value)*100

print("~~~~~~~~~~~~~~~~")

print("Difference in mean patch size for the SRME: ")
((b$value-a$value)/b$value)*100

(c <- patch.long %>% filter(metric=="area_md",source=="Aspen10m"))
(d <- patch.long %>% filter(metric=="area_md",source=="LFEVT"))

print("Mean and median patch sizes: ")
paste0("Aspen10m mean: ",a$value)
paste0("LFEVT mean: ",b$value)
paste0("Aspen10m median: ",c$value)
paste0("LFEVT mean: ",d$value)



print("Difference in median area: ")
((d$value-c$value)/d$value)*100

print("Mean Perimeter area ratio: ")
(a <- patch.long %>% filter(metric=="par_mn",source=="Aspen10m"))
(b <- patch.long %>% filter(metric=="par_mn",source=="LFEVT"))

print("Difference in PAR: ")
((b$value-a$value)/b$value)*100

rm(a,b,c,d)
```

Boxplot as facet wrap for patch metrics:

```{r fig.height=5, fig.width=10}

brewer.pal(n=5,"Set1")

cols <- c("#005a32","#a1d99b")

(df <- patch_metrics %>%
  # mutate(area_ha = area*100) %>%
  select(-c(X,index,shape_index)) %>%
  pivot_longer(contains(c("area","perimeter_area_ratio"))) %>%
  arrange(source, desc(value)) %>%
  mutate(name = as.character(name),
         name = recode(name,
                       "area" = "Patch Size (ha)",
                       "perimeter_area_ratio" = "Perimeter/Area Ratio")))

df$source <- factor(df$source,
                    levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))
 
(f8a <- ggplot(data=df, aes(y = value, x = factor(source), fill = factor(region))) +
  geom_boxplot(outlier.size = 0.2) +
  scale_y_continuous(trans="log10",labels=label_number_si(accuracy = 1)) +
  scale_fill_manual(values=cols) +
  facet_wrap(~name, scales = "free_y", nrow=1) +
  labs(x="\nData Source",y="Value",title="Patch Metrics", fill="Region: ") +
  theme_light(12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=11),
        axis.text.y = element_text(angle = 0, vjust=0.1, size=11),
        axis.title.y = element_text(size=12, face="italic", vjust=1),
        axis.title.x = element_text(size=12, face="italic", vjust=-1),
        plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm"),
        legend.position="top",
        legend.spacing.x = unit(0.5,"cm"),
        text = element_text(family = "Arial")))

ggsave(f8a, file = "../../figures/Figure8A_patch_metrics.png", dpi = 300) # adjust dpi accordingly

```

Plot class metrics as facet wrap:

```{r fig.height=5, fig.width=10, message=F}

# Calculate area in square meters
srme_area_km2 <- st_area(srme) / 1e6
wrnf_area_km2 <- st_area(wrnf) / 1e6

(df <- class_metrics %>%
  mutate(total_area = total_area*0.01,
         prop_area = if_else(region=="SRME", as.double((total_area/srme_area_km2*100)), 0.0),
         prop_area = if_else(region=="WRNF", as.double((total_area/wrnf_area_km2*100)), prop_area)) %>%
  select(-c(X)) %>%
  pivot_longer(cols = c(contains("_")),
               names_to = "metric",
               values_to = "value") %>%
  mutate(metric = as.character(metric),
         metric = recode(metric,
                         "n_patch" = "Number of Patches",
                         "patch_den" = "Patch Density",
                         "total_area" = "Total area (km2)",
                         "prop_area" = "Proportion of Area")))

df$source <- factor(df$source, levels=c('Aspen10m', 'Aspen30m', 'LFEVT', 'TreeMap', 'ITSP'))
head(df)

(f8b <- ggplot(data=df, aes(y=value, x=factor(source), fill=factor(region))) +
  geom_bar(stat="identity", position="dodge", width=0.7) +
  scale_y_continuous(labels=scales::label_number_si(accuracy = 1)) +
  scale_fill_manual(values=cols) +
  labs(x="", y="Value", title="Landscape Metrics", fill="Region: ") +
  theme(axis.title.x = NULL) +
  facet_wrap(~metric, scales = "free_y") +
  theme_light(12) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=11),
        axis.text.y = element_text(angle = 0, vjust=0.1, size=11),
        axis.title.y = element_text(size=12, face="italic", vjust=0.5),
        axis.title.x = element_text(size=12, face="italic", vjust=-0.5),
        plot.margin = unit(c(0.5,0.5,0.5,0.5),"cm"),
        legend.position = "top",
        legend.spacing.x = unit(0.5,"cm"),
        text = element_text(family = "Arial")))

ggsave(f8b, file = "../../figures/Figure8B_landscape_metrics.png", dpi = 300) # adjust dpi accordingly

```

```{r fig.width=10, fig.height=10}
(arr <- ggarrange(f8b,f8a,nrow=2,ncol=1,labels=c("A","B"), common.legend = T))
ggsave(arr, file="../../figures/Figure8_Landscape_Patch_Metrics.png", dpi=300)
```

The 10-m aspen classification identified Xx more patch than reference images:

```{r}

print("% Difference in number of patches across the Southern Rockies: ")
a <- df %>% filter(region=="SRME",metric=="Number of Patches",source=="Aspen10m")
b <- df %>% filter(region=="SRME",metric=="Number of Patches",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("% Difference in number of patches across the White River NF: ")
a <- df %>% filter(region=="WRNF",metric=="Number of Patches",source=="Aspen10m")
b <- df %>% filter(region=="WRNF",metric=="Number of Patches",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("~~~~~~~~~~~~~")

print("~~~~~~~~~~~~~")

print("% Difference in patch density: ")
a <- df %>% filter(metric=="Patch Density",source=="Aspen10m")
b <- df %>% filter(metric=="Patch Density",source=="LFEVT")
((b$value-a$value)/b$value)*100

print("% Difference in total area:")
a <- df %>% filter(metric=="Total area (km2)",source=="Aspen10m")
aa <- df %>% filter(metric=="Total area (km2)",source=="Aspen30m")
b <- df %>% filter(metric=="Total area (km2)",source=="LFEVT")
((b$value-a$value)/b$value)*100
((b$value-aa$value)/b$value)*100

rm(a,aa,b)

```


# Supplemental

Figure S1: Quaking Aspen Phenology

Load the spatial block grid and phenology time-series summaries by spatial block for the Southern Rockies. Join the phenology summaries to their geometries.

```{r}
# Load the grids, keep the elevation attribute and TreeMap sum (aspen area)
grid <- st_read('../../data/spatial/mod/boundaries/spatial_block_grid_50km2.gpkg',
                quiet=T) %>%
  select(grid_id,elevation_mn,treemap_sum,treemap_pct)

# Load the phenology by spatial block grid
phenology <- read_csv('../../data/tabular/mod/phenology/viirs_phenology_by_grid_in_aspen.csv',
                      show_col_types = FALSE) %>%
  rename(fid = `system:index`) %>%
  mutate(grid_id = str_sub(fid, -7),
         year = as.integer(str_sub(fid, 1, 4))) %>%
  select(-c(fid,label,count,.geo)) %>%
  # Create DOY versions of the phenology metrics for plotting and statistical analysis
  mutate(
    season_length = Growing_Season_Length_1_median,
    doy_midgreenup = yday(Date_Mid_Greenup_Phase_1_median),
    doy_midsenescence = yday(Date_Mid_Senescence_Phase_1_median),
    doy_green_dec = yday(Onset_Greenness_Decrease_1_median),
    doy_green_inc = yday(Onset_Greenness_Increase_1_median),
    doy_green_max = yday(Onset_Greenness_Maximum_1_median),
    doy_green_min = yday(Onset_Greenness_Minimum_1_median)
  ) %>%
  left_join(grid%>%as_tibble(), by="grid_id") %>%
  select(grid_id,year,elevation_mn,season_length,doy_midgreenup,doy_midsenescence,
         doy_green_dec,doy_green_inc,doy_green_max,doy_green_min)

glimpse(phenology)
```

Spatial maps of the key phenology metrics.

```{r fig.width=4, fig.height=5}

# Calculate the median phenology metrics
phenology.md <- phenology %>%
  group_by(grid_id) %>%
  summarise(across(starts_with("doy"), median, na.rm=T))

# Join to the spatial data and pivot longer
grid.l <- grid %>% 
  left_join(phenology.md, by="grid_id") %>%
  pivot_longer(cols = starts_with("doy"), names_to = "metric", values_to = "value") %>%
  filter(treemap_pct > 0.05) # Keep only blocks with some aspen cover

ordered_metrics <- c(
  "doy_green_inc","doy_midgreenup","doy_green_max",
  "doy_green_dec","doy_midsenescence","doy_green_min") 

# Tidy the names for plotting
metric_names <- c(
  doy_green_inc = "Onset Greenness Increase",
  doy_midgreenup = "Mid Greenup Phase",
  doy_green_max = "Onset Greenness Maximum",
  doy_green_dec = "Onset Greenness Decrease",
  doy_midsenescence = "Mid Senescence Phase",
  doy_green_min = "Onset Greenness Minimum"
)

# Fix the factor levels and labels
grid.l$metric <- factor(grid.l$metric, levels = ordered_metrics, labels = metric_names)

head(grid.l)
```

```{r fig.width=2.4, fig.height=5}

metrics <- unique(grid.l$metric)

plots <- list()

for (m in metrics){
  # Filter for the metric
  gdf <- grid.l %>% filter(metric == m)
  
  # Map
  p <- ggplot() +
    geom_sf(data=grid, fill=NA) +
    geom_sf(data=gdf, aes(fill=value)) +
    scale_fill_continuous(low = "lightgreen", high = "darkgreen",
                          labels = function(x) format(as.Date(as.numeric(x), origin="1970-01-01"), "%b %d")) +
    geom_sf(data=srme,fill=NA,color="black",size=2.5) +
    labs(fill="", title=m) +
    theme_void(12) +
    theme(legend.position = "right",
          legend.text = element_text(angle = 0, size=9),   # Ensure labels are not rotated
          plot.title = element_text(hjust = 0.5, size=10),
          plot.margin = ggplot2::margin(0.1, 5, 0.1, 5, "mm")
    ) + 
    guides(fill = guide_colourbar(
      barwidth = 0.5, 
      barheight = 6, 
      ticks = FALSE,
      label.position = "right", 
      label.theme = element_text(size = 8))
    )
  # Save the individual map
  ggsave(p, file=paste0("../../figures/FigureS1B_Phenology_by_Elevation",m,".png"), dpi=300)
  print(p)
  plots[[m]] <- p
}

```

Create a combined plot for four metrics.

```{r fig.width=6.75, fig.height=6.5}

fs1a <- ggarrange(plots[[1]], plots[[3]], plots[[2]], plots[[6]],
                  ncol = 2, nrow = 2, widths=c(1,1,1,1), heights=c(1,1,1,1),
                  align = "hv", labels = c("A","B","C","D"))
fs1a
ggsave(fs1a, file="../../figures/FigureS1A_PhenologyMaps.png", dpi=300)

```


Plot the relationship with elevation across metrics.

```{r message=F, warning=F}

metrics <- c("Mid Greenup Phase", "Onset Greenness Decrease", "Mid Senescence Phase", "Onset Greenness Minimum")

df <- grid.l %>% filter(metric %in% metrics)

# Individual plots
for (m in metrics){
  # Filter for the metric
  gdf <- grid.l %>% filter(metric == m)
  
  # Map
  p <- ggplot(data=gdf, aes(x=value,y=elevation_mn)) +
    geom_smooth(method="lm",colour="gray40", fill="gray70", size=0.5) +
    geom_point(size=0.4) +
    theme_bw(7) +
    theme(axis.text = element_blank(),
          axis.title = element_text(size=6),
          axis.ticks = element_blank()) +
    labs(x="Day of Year",y="Elevation")
  ggsave(p, file=paste0("../../figures/FigureS1B_Phenology_by_Elevation_",m,".png"), width=1.5, height=1.5)
  print(p)
}

# Facet plot
(fs1b <- ggplot(data=df, aes(x=value,y=elevation_mn)) +
  geom_smooth(method="lm",colour="gray40", fill="gray70", size=0.8) +
  geom_point(size=0.8) +
  facet_wrap(~metric, scales="free_x", nrow=2) +
  theme_minimal(12) +
  theme(plot.title = element_text(size=10),
        axis.text = element_text(size=8),
        axis.title = element_text(size=10),
        strip.text = element_text(size=8),
        panel.spacing = unit(2.5, "mm")) +
  labs(x="Day of Year",y="Elevation", tag="B"))

# Save out
ggsave(fs1b, file="../../figures/FigureS1B_Phenology_by_Elevation.png", dpi=300)

rm(metrics,df)

```

Merge the two plots.

```{r fig.width=4.5, fig.height=5}
(fs1 <- ggarrange(fs1a, fs1b, nrow=2, ncol=1, align="v"))
ggsave(fs1, file="../../figures/FigureS1_Phenology.png", dpi=300)
```

```{r}
# Reshape from wide to long format
phenology.l <- phenology %>%
  pivot_longer(
    cols = c(doy_midgreenup,doy_midsenescence,doy_green_dec,
             doy_green_inc,doy_green_max,doy_green_min),
    names_to = "metric",
    values_to = "doy"
  )

ordered_metrics <- c(
  "doy_green_inc","doy_midgreenup","doy_green_max",
  "doy_green_dec","doy_midsenescence","doy_green_min") 

metric_names <- c(
  doy_green_inc = "Onset Greenness Increase",
  doy_midgreenup = "Mid Greenup Phase",
  doy_green_max = "Onset Greenness Maximum",
  doy_green_dec = "Onset Greenness Decrease",
  doy_midsenescence = "Mid Senescence Phase",
  doy_green_min = "Onset Greenness Minimum"
)

phenology.l$metric <- factor(
  phenology.l$metric, 
  levels = ordered_metrics, 
  labels = metric_names
)

# Create the plot with facet_wrap
ggplot(phenology.l, aes(x=factor(year), y=doy)) +
  geom_boxplot() +
  facet_wrap(~ metric, scales = "fixed") +
  theme_minimal() +
  labs(title = "DOY Phenology Metrics (2013-2022)",
       x = "Year",
       y = "Day of Year",
       fill = "Year") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Stacked box plots
ggplot(phenology.l, aes(x=factor(year), y=doy, fill=metric)) +
  geom_boxplot(width=1) +
  theme_minimal() +
  labs(x = "Year",
       y = "Day of Year",
       fill = "Metric") +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1),
        legend.position = "top")
```

ROC, F1, MCC:

```{r}

accmeas <- read_csv('../../data/tabular/mod/results/accmeas_prop.csv')

# Calculate the averages for each cutoff value across model runs

accmeas.mn <- accmeas %>%
  mutate(cutoff = as.character(cutoff)) %>%
  group_by(cutoff) %>%
  summarise(
    prMn = mean(prSize,na.rm=T), # size of presence data (mean)
    prSd = sd(prSize,na.rm=T), # size of presence data (sd)
    bgMn = mean(bgSize,na.rm=T), # size of background data (mean)
    bgSd = sd(bgSize,na.rm=T), # size of background data (sd)
    fprMn = mean(fpr,na.rm=T), # False Positive Rate (mean)
    fprSd = sd(fpr,na.rm=T),
    tprMn = mean(tpr,na.rm=T), # True Positive Rate (mean)
    tprSd = sd(tpr,na.rm=T),
    precision = mean(precision,na.rm=T), # precision (mean)
    precisionSd = sd(precision,na.rm=T), 
    recall = mean(recall,na.rm=T), # recall (mean)
    recallSd = sd(recall,na.rm=T),
    f1 = mean(f1,na.rm=T), # F1 score (mean)
    f1Sd = sd(f1,na.rm=T),
    gmean = mean(gmean,na.rm=T), # Geometric Mean (mean)
    gmeanSd = sd(gmean,na.rm=T),
    mcc = mean(mcc,na.rm=T), # Matthew's Correlation Coefficient (mean)
    mccSd = sd(mcc,na.rm=T),
    accuracy = mean(accuracy,na.rm=T), # Overall accuracy (mean)
    accuracySd = sd(accuracy,na.rm=T)
  ) %>%
  ungroup() %>%
  mutate(cutoff = round(as.double(cutoff),3))

# Calculate optimum threshold based on F1 statistic

cutoffOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$cutoff
precisionOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$precision
recallOptF1Mn = accmeas.mn[which.max(accmeas.mn$f1),]$recall
fprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$fprMn
tprOptMn = accmeas.mn[which.max(accmeas.mn$f1),]$tprMn
max_f1 <- max(accmeas.mn$f1, na.rm = TRUE)

```


```{r warning=F, message=F}

# ROC Curve and label the AUC value (approximation)

# Get the AUC approx

# Ensure data is sorted by FPR
accmeas_mn_sorted <- accmeas.mn[order(accmeas.mn$fprMn), ]
# Compute AUC using trapz function in 'pracma'
auc_avg_approx <- trapz(accmeas_mn_sorted$fprMn, accmeas_mn_sorted$tprMn)

fs2a <- ggplot(data=accmeas) +
  geom_line(aes(x=fpr,y=tpr,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  geom_line(data=accmeas.mn, aes(x = fprMn, y = tprMn), color = "black", size = 0.8) +  # ROC curve average
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='False Positive Rate', y='True Positive Rate', tag="A") +
  geom_point(aes(x = fprOptMn, y = tprOptMn),
             color = "red", size = 3, shape = 19) +  # optimal threshold point
  geom_text(aes(x=fprOptMn, y=tprOptMn),
            label = paste0('Optimal threshold: ', round(cutoffOptMn,3),'\nApprox. AUC: ', round(auc_avg_approx,3)),
            nudge_x = 0.38, nudge_y = -0.08, size = 3.5) +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +  # diagonal
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

fs2b <- ggplot(data=accmeas) +
  geom_line(aes(x=cutoff,y=f1,color=factor(model)),linewidth=0.4) +
  scale_color_viridis_d(option="turbo") +
  geom_line(data=accmeas.mn, aes(x=cutoff, y = f1), color = "black", size = 0.8) +  # ROC curve average
  # geom_vline(xintercept=0.424, linetype="dashed", color="black") +
  geom_point(aes(x=cutoffOptMn, y=max_f1),
             color = "red", size = 3, shape = 19) +
  geom_text(aes(x=cutoffOptMn, y=max_f1),
            label = paste0('Optimal threshold: ', round(cutoffOptMn,3)),
            nudge_x = 0.0, nudge_y = 0.08, size = 3.5) +
  scale_x_continuous(limits=c(0,1)) +  # Set x axis limits from 0 to 1
  scale_y_continuous(limits=c(0,1)) +
  labs(x='Threshold', y='F1 Score', tag="B") +
  coord_fixed(ratio = 1) +  # to keep the x and y axes scales same
  theme_light() +
  theme(legend.position = "none",
        axis.title.y = element_text(size=11,face="italic",
                                    margin = unit(c(0,0.4,0,0), "cm")),
        axis.title.x = element_text(size=11,face="italic",
                                    margin = unit(c(0.4,0,0,0), "cm")),
        axis.text = element_text(size=10),
        strip.text.x = element_text(size = 11))

(fs2 <- ggarrange(fs2a,fs2b))

ggsave(fs2, file="../../figures/FigureS2_AUC_F1Max.png", dpi=300)

rm(fs2,fs2a,fs2b,accmeas_mn_sorted,auc_avg_approx)

```

Table S1: Performance metrics for the optimum cutoff value

Create a pretty table.

```{r}

library(flextable, quietly = T)

# Get the best F1 score for each model run
accmeas.best <- accmeas %>% 
  mutate(model = as.factor(model)) %>%
  group_by(model) %>% 
  top_n(1,f1) %>%
  ungroup() %>%
  mutate(model_iter = row_number()) %>%
  select(model,prSize,bgSize,tpr,precision,recall,f1,cutoff)

head(accmeas.best,10)

# Fix names and add units
names(accmeas.best) <- c("Model Seed",
                         "# of Presence",
                         "# of Background",
                         "True Positive Rate",
                         "Precision",
                         "Recall",
                         "F1-Score",
                         "Threshold")

# Set font name for table
fontname <- "Times New Roman"

# Create the flextable
(ft1 <- flextable(accmeas.best) %>%
 font(fontname = fontname, part = "all") %>%
 autofit() %>% fit_to_width(6.5))
print(ft1, preview = "docx")

# Write to a CSV
write_csv(accmeas.best, "../../figures/TableS1_Accuracy_MaxF1.csv")

```

Clean up!

```{r}

```
